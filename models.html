<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title> Models of Computation </title>
    <style type="text/css">
        body {
            font-family: "Century Gothic", serif;
            margin: 50px;
        }

        h1 {
            color: #2e4566;
        }

        h2 {
            text-decoration: underline;
            color: #2f5496;
        }

        h3 {
            color: #5b9bd5;
        }

        h4 {
            font-weight: normal;
            color: #70c4f5;
        }

        hr {
            border-color: #59a7ea;
        }

        keyword {
            color: #c976c6;
            font-weight: bold;
        }

        code {
            font-family: Consolas, monospace;
            color: #4913d3;
        }

        pre {
            margin:10px;
            font-family: Consolas, monospace;
            color: #4913d3;
        }

        #topBtn {
            display: none;
            position: fixed;
            bottom: 80px;
            right: 20px;
            z-index: 99;
            border: none;
            outline: none;
            background-color: #3460a9;
            color: white;
            cursor: pointer;
            padding: 15px;
            border-radius: 10px;
        }

        #topBtn:hover {
            background-color: #555;
            opacity: 0.5;
        }

        #homeBtn {
            display: block;
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 99;
            border: none;
            outline: none;
            background-color: #3460a9;
            color: white;
            cursor: pointer;
            padding: 15px;
            border-radius:10px;
        }

        #homeBtn:hover {
            background-color: #555;
            opacity: 0.5;
        }
    </style>
</head>
<body>
<hr/>
<h1 align="center"> LI Models of Computation </h1>
<p align="center"> Template and style original: <keyword>Rhys Barrett</keyword>. </p>

<hr/>
Table of Contents (<a href="#" onclick="var expanded=this.innerHTML==='expand'; var subtopics=document.getElementsByClassName('subtopic'); for (var i = 0; i < subtopics.length; i++) { subtopics[i].style.display=(expanded ? '' : 'none'); } this.innerHTML=(expanded ? 'collapse' : 'expand');">expand</a>)
<ol>
    <li> <a href="#fsa"> Language and Automata </a> <ul class="subtopic" style="display: none">
        <li> <a href="#fsa1"> Problems and Computers </a> </li>
        <li> <a href="#fsa2"> Regular Expression </a> </li>
        <li> <a href="#fsa3"> Finite State Automaton</a> </li>
        <li> <a href="#fsa4"> Bisimulation </a> </li>
    </ul> </li>
    <li> <a href="#dec"> Decidability </a> <ul class="subtopic" style="display: none">
        <li> <a href="#dec1"> Decision Problems </a> </li>
        <li> <a href="#dec2"> The Halting Theorem </a> </li>
        <li> <a href="#dec3"> Properties of Code </a> </li>
        <li> <a href="#dec4"> Riceâ€™s Theorem </a> </li>
    </ul></li>
    <li> <a href="#tm"> Turing Machines </a> <ul class="subtopic" style="display: none">
        <li> <a href="#tm1"> Executing TMs </a> </li>
        <li> <a href="#tm2"> Designing TMs </a> </li>
        <li> <a href="#tm3"> Macros </a> </li>
        <li> <a href="#tm4"> Extension to TMs </a> </li>
        <li> <a href="#tm5"> Church's Thesis </a> </li>
    </ul></li>
    <li> <a href="#comp"> Complexity </a> <ul class="subtopic" style="display: none">
        <li> <a href="#comp1"> Complexity of Algorithms </a> </li>
        <li> <a href="#comp2"> Complexity of Problems </a> </li>
        <li> <a href="#comp3"> O notation </a> </li>
        <li> <a href="#comp4"> NP Problems </a> </li>
        <li> <a href="#comp5"> NP-complete Problems </a> </li>
        <li> <a href="#comp6"> Satisfiability </a> </li>
    </ul></li>
    <li> <a href="#lambda"> Lambda Calculus </a> <ul class="subtopic" style="display: none">
        <li> <a href="#lambda1"> Lambda Application </a> </li>
        <li> <a href="#lambda2"> Evaluating Expressions </a> </li>
        <li> <a href="#lambda3"> Typed Lambda Calculus </a> </li>
        <li> <a href="#lambda4"> Typed vs Untyped </a> </li>
    </ul></li>
    <li> <a href="#papers"> Past Papers </a> </li>
</ol>

<hr/>

<h2 id="fsa"> Languages and Automata </h2>
<h3 id="fsa1"> Problems and Computers </h3>
<p> <em> This module is about problems and computers, except for the last part which is about &lambda;-calculus. </em> </p>

<p> Some questions that we can ask ourselves: </p>
<ul>
    <li> What problems can be solved on a computer? </li>
    <li> What problems can be solved on a computer with only finitely many states? </li>
    <li> What problems can be solved <em> fast </em> on a computer? </li>
    <li> What does "fast" mean anyway? </li>
    <li> What does "computer" mean anyway? </li>
    <li> etc.. </li>
</ul>

<h3> Language Membership Problems </h3>
Suppose that we have a set of characters, the alphabet &Sigma;. <br/>
A word (or string) is a finite sequence of characters. <br/> We write &Sigma;* for the set of all words. We can concatenate words. <br/>
The empty word is written as &epsilon;. <br/>
A language is a set of words, which means that it is a subset of &Sigma;*. <br/>

<p> Example language 1 <br/>
    Let's say the alphabet is {a,b,c}. The image below shows some example languages: <br/>
    <img src="images/models/fsa1.JPG"/> <br/>
    This can be applicable in real-life situations such as: <br/>
    <img src="images/models/fsa2.JPG"/> <br/>
    In all of these examples, somebody has provided a word and we want to know whether it is an acceptable word. Ideally, we want a computer program that will tell us. </p>

<h3 id="fsa2"> Regular Expressions </h3>
<p> Every regular expression gives rise to a language &ndash; a <em> regular language </em>. Some useful notations for describing languages: </p>
<ul>
    <li> We write <em> Empty </em> for the language consisting of no words, or the empty set. </li>
    <li> We write <em> a </em> for the language consisting of the single-character word <em> a </em> </li>
    <li> We write &epsilon; for the language consisting of just the empty word. </li>
    <li> Suppose <em> L </em> and <em> L' </em> are languages. <ul>
        <li> We write <em> LL' </em> for the set of words that are a concatenation of a word in <em> L </em> and a word in <em> L' </em> </li>
        <li> We write <em> L | L'</em> for the set of words that are either in <em> L </em> or <em> L' </em>. This is basically the union of <em> L </em> and <em> L' </em>. </li>
        <li> We write <em> L* </em> for the set of words that are a concatenation of some number of words in <em> L </em>. Note that "some number" might be 0, so the empty word is in <em> L* </em>. </li>
    </ul> </li>
</ul>
<p> All expressions built up this way makes a regular expression. A regular expression <em> E </em> can be either Empty, &epsilon;, <em> a, b c, </em> or anything in the alphabet, <em> EE' </em>, <em> E | E' </em>, or <em> E* </em>. </p>

<p> Just like arithmetic expressions, you can't make sense of regular expressions without knowing the precedence rules. <em> * </em> has the highest precedence, then juxtaposition (putting things next to each other, you juxtapose AB in algebra means A * B, or <strong> concatenation</strong>) then |.</p>

<p style="font-weight: bold"> Example exercises </p>
<ol>
    <li> Is the word <em> abb </em> in the language <em> a(b|c)* </em> ? &emsp; <span style="border: 1px solid darkgoldenrod;" onmouseenter="this.innerHTML='Yes, because a matches then b then b since (b|c)*'"> Hover for answer </span> </li>

    <li> Is the word <em> abc </em> in the language <em> a(b|c)* </em> ? &emsp; <span style="border: 1px solid darkgoldenrod;" onmouseenter="this.innerHTML='Yes, because a matches then b then c since (b|c)*'"> Hover for answer </span> </li>

    <li> Is the word <em> aabbab </em> in the language <em> (a(b|c)*)* </em> ? &emsp; <span style="border: 1px solid darkgoldenrod;" onmouseenter="this.innerHTML='Yes, because a abb ab'"> Hover for answer </span> </li>

    <li> Is the word <em> abbabca </em> in the language <em> (ab|ba)* </em> ? &emsp; <span style="border: 1px solid darkgoldenrod;" onmouseenter="this.innerHTML='No, because c is not in the language'"> Hover for answer </span> </li>

    <li> is the language <em> ((a|b)(b|c))* </em> the same as the language <em> (ab|ac|bb|bc)* </em> ? &emsp; <span style="border: 1px solid darkgoldenrod;" onmouseenter="this.innerHTML='Yes, because they are can form either ab or ac or bb or bc, then * the whole thing'"> Hover for answer </span> </li>

    <li> For each regexp <em> E </em>, could you write a program that takes a word <em> w </em> and says whether it's in the language represented by E? &emsp; <span style="border: 1px solid darkgoldenrod;" onmouseenter="this.innerHTML='Yes, a very efficient one'"> Hover for answer </span> </li>

    <li> Could you write a single program that takes a word <em> w </em> and a regexp <em> E </em> and says whether <em> w </em> is in the language represented by <em> E </em> ? &emsp; <span style="border: 1px solid darkgoldenrod;" onmouseenter="this.innerHTML='Yes'"> Hover for answer </span> </li>

    <li> Could you write a program that takes two regexps and says whether they represent the same language? &emsp; <span style="border: 1px solid darkgoldenrod;" onmouseenter="this.innerHTML='Yes, but it is not obvious'"> Hover for answer </span> </li>
</ol>

<p> Regular expression in theoretical computer science means an expression built up from the above operations and nothing more. The term has come to be used in Linux etc. to include various other operations. Regexps are also used in a somewhat different sense to find occurrences of words within a larger word. </p>

<p> <strong> Kleene's theorem </strong> says a language is regular (i.e. recognized by a regular expression) if and only if it is accepted by a finite state automaton. </p>

<p> Here are a few common abbreviations, it is optional to use these. <br/> <img src="images/models/fsa3.JPG"/> </p>


<h2 id="fsa3"> Finite State Automaton </h2>
<p> A finite state automaton over &Sigma; is </p>
<ul>
    <li> a finite set &Qopf; of states (<em> nodes </em>) </li>
    <li> a transition function &Qopf; &times; &Sigma; &rightarrow; &Qopf; (<em> paths, edges </em>) </li>
    <li> a set Acc &subseteq; &Qopf; of accepting states (<em> double nodes </em>) </li>
    <li> an initial state <em> q<sub>0</sub> </em> &epsi; &Qopf; (<em> diamond node </em>) </li>
</ul>
<p> Every finite state automaton has an associated language. To convert a partial FSA into a complete FSA, simply add an error state. </p>

<p> <span style="font-weight: bold;"> Removing &epsilon;-transitions </span> <br/> There's a <em> slow a-transition </em> from state q to state q' when, starting from state q we can follow some number of &epsilon;-transition, and end in state q'. A state q is <em> slowly accepting </em> when, starting from state q we can follow some number of &epsilon;-transitions and reach an accepting state. </p>

<p> But if we want to remove all &epsilon;-transitions, we keep the set of states, keep the initial state, replace the slow transitions by transitions, and replace slowly accepting states by accepting states. After removing all &epsilon;-transitions, we will obtain a Non-Deterministic Finite Automaton (NDFA). </p>

<p> <span style="font-weight: bold;"> Determinisation </span> <br/> Given a NDFA, we can form a Deterministic Finite Automaton (DFA) by first having the states a subset of &Qopf;, then from a state U &subseteq; &Qopf;, when we input a, take the set of all states that we can reach by an a-transition from a state in U. An accepting state is any that contains a state in Acc. The initial state is {<em>q<sub>0</sub></em>}. </p>

<p> <span style="font-weight: bold;"> Converting a regexp into a DFA </span> <br/> Convert first into NDFA by removing &epsilon;-transitions, and then determinise as mentioned above. </p>

<p> <span style="font-weight: bold;"> Converting DFA into a regexp </span> <br/> So say we have states {0,1,...,<em>n</em> &ndash; 1}. <br/> For any state <em>i</em> and <em>j</em> and any <em>k &le; n</em>, we want a regexp <em> E <span style="position: relative; top: 0.5em; left: -0.3em;"> <em> i&rightarrow;j</em></span> <span style="position:relative; top: -0.5em; left: -1.8em;"> &lt;k </span> </em> <br/> that accepts those words that take us from <em>i</em> and <em>j</em> with intermediate states all &lt; <em>k</em>. <br/>
    The image below shows the formula to convert DFA into a regexp. <br/> <br/> <img src="images/models/fsa4.JPG"/> </p>

<p> <em> Note: Every node in NDFA will always have equal number of transitions, and that number is all the possible transitions, and each of them are labelled with sets of states. </em> </p>

<p> <span style="font-weight: bold;"> Operations on Regular Languages </span> <br/> We can use Kleene's theorem to prove that some languages are regular. Firstly, the complement of a regular language L is regular. <br/> The proof is to get a DFA that recognises L, and by Kleene's theorem, the new complement automaton will have accepting states that are the set &Qopf;\Acc. This recognises the complement of L, so the latter is regular. <br/> The intersection of regular languages L and L' is regular (Corollary), because it's the complement of the union of the complements L and L' by Kleene's theorem. If L and L' are regular, then L \ L' is regular because L &cap; (&Sigma; \ L') by corollary. </p>

<p> <span style="font-weight: bold;"> Proving a language is not regular </span> <br/> We can prove this by finding an L-distinguishing suffix for words. Suppose we have a DFA that recognises the language L. And if we have words that have an L-distinguishing suffix, then each word must take us from the initial state to different states. <br/>
    If there is a countable sequence of distinctive words, then the minimum states of the DFA will be equal to the size of the set. <br/>
    However, if it is an infinite sequence of distinctive words, then there will be no DFA, and by Kleene's theorem the language is not regular. (<em>Myhill-Nerode Theorem</em>)<br/> </p>
<p> Also by the use of <strong> pumping lemma</strong>, which says that for any regular language L there exists a constant p such that any word w in L with length at least p can eb split into three substrings, w = xyz, where the middle portion of y must not be empty, such that the words xz, xyz, xyyz, xyyyz, ... constructed by repeating y zero or more times are still in L. The repetition process is called "pumping". Moreover, the pumping lemma guarantees that the length of xy will be at most p, imposing a limit on the way in which w may be split. Finite languages trivially satisfy the pumping lemma by having p equal to the maximum string length in L plus one. </p>

<h3 id="fsa4"> Bisimulation </h3>
<p> An <em> unpointed automaton </em> is one that has no initial state. <br/> A <strong> bisimulation </strong> between unpointed total deterministic automata (&Qopf;, &sigma;, Acc) and (&Qopf;', &sigma;', Acc') with the same alphabet L is a relation R &subseteq; &Qopf; &times; &Qopf;' such that if <em> qRq' </em> and a &epsi; L then &sigma;(q,a)R&sigma;'(q',a), and if <em> qRq' </em> then q &epsi; Acc iff q' &epsi; Acc'. <br/>
    Suppose that we have to unpointed automata for the same alphabet L. Then a state <em>q<sub>0</sub></em> &epsi; Q is bisimilar to a state <em>q'<sub>0</sub></em> if and only if they accept the same language. To prove this, show that for any word <em> w </em>, if <em>qRq'</em> then <em> q </em> accepts <em> w </em> if and only if <em> q' </em> accepts <em> w</em>. This is by induction on <em> w</em>. </p>

<p> The theorem is that two states accept the same language iff they are bisimilar. </p>

<h3 id="fsa5"> Minimisation </h3>
<p> To minimise an automaton means to throw away unreachable states and to identify bisimilar states. </p>
<ol>
    <li> Draw a table for all pairs of states (P,Q) </li>
    <li> Mark all pairs where P &in; Acc and Q &notin; Acc </li>
    <li> If there are any unmarked pairs (P,Q) such that transitions [&sigma;(P,x), &sigma;(Q,x)] is marked, then mark [P,Q] where 'x' is an input symbol. Repeat this until no more markings can be made. </li>
    <li> Combine all the unmarked pairs and make them a single state in the minimised DFA </li>
</ol>

<hr/>

<h2 id="dec"> Decidability </h2>
<h3 id="dec1"> Problems </h3>
<p>Every problem has an input and output and can also be called a function.</p>
<p>We don&rsquo;t consider problems where the set of inputs is finite as this can be solved via a table hence a computer isn&rsquo;t required. We only consider problems where the set of inputs is a countably infinite set which in turn means the set of acceptable outputs is also a countably infinite set.</p>
<p>Decision Problem - A problem whose result is either yes or no.</p>
<p>If the set of inputs is the set of words over some alphabet, this subset is a language</p>
<p>For example if we have the problem &ldquo;given a positive integer, is it prime?&rdquo; which is essentially the function that maps a positive integer to &ldquo;True&rdquo; if it&rsquo;s prime and &ldquo;False&rdquo; otherwise. Which means the set of acceptable outputs is the subset of the set of positive integers consisting of all prime numbers.</p>
<p>A decision problem is decidable when it can be solved on a computer</p>
<p>A function is computable when it can be computed by a computer</p>
<p>A subset of a set of inputs (eg a language) is decidable when the decision problem associated to it can be solved on a computer</p>
<p>For example &ldquo;Given a n*n*n*n Sudoku problem, find a solution if it exists otherwise return None&rdquo; is not a decision problem as there are is a finite set of inputs.</p>
<p>If we can solve problem Q using a black box that solves problem P, we&rsquo;ve reduced problem Q to problem P. In this situation if P is decidable then so is Q, if Q is undecidable then so is P.<br /><br /></p>
<h3 id="dec2"> The Halting Problem </h3>
<p>The Halting problem is &ldquo;given a nullary program does it terminate or not?&rdquo; Turing proved the halting problem to be undecidable.</p>
<p>Proof:</p>
<p>Assume the halting problem is decidable</p>
<p>&nbsp;</p>
<ol>
    <li>Now consider the unary halting problem: given a unary Java method</li>
</ol>
<p style="padding-left: 60px;"><strong>void f (String x) {</strong></p>
<p style="padding-left: 60px;"><strong>&nbsp;&nbsp;...</strong></p>
<p style="padding-left: 60px;"><strong>}</strong></p>
<p style="padding-left: 60px;">and a string <strong>y</strong>, does <strong>f </strong>terminate when called with argument <strong>y</strong>?</p>
<p style="padding-left: 60px;">We can reduce the unary halting problem to the nullary halting problem.</p>
<p style="padding-left: 60px;">Replace x in the body of <strong>f</strong> by the string <strong>y</strong>. That gives a nullary program, which terminates iff <strong>f</strong> terminates when called with argument <strong>y</strong>. So the unary halting problem is decidable.</p>
<p style="padding-left: 60px;">That means there is a Java program:</p>
<p style="padding-left: 60px;"><strong>boolean haltcheck (String somemethod, String y) {</strong></p>
<p style="padding-left: 60px;"><strong>&nbsp; &hellip;</strong></p>
<p style="padding-left: 60px;"><strong>}</strong><br /> where <strong>somemethod </strong>is the body of a unary method (<strong>M</strong>). When applied to <strong>M</strong> and<strong> y</strong>, this method returns true <strong>M</strong> applied to <strong>y </strong>terminates, otherwise it returns false.</p>
<ol start="2">
    <li>Next we turn this into a program</li>
</ol>
<p style="padding-left: 60px;"><strong>void hangcheck (String somemethod, String y) {</strong></p>
<p style="padding-left: 60px;"><strong>&nbsp;&nbsp; if haltcheck (somemethod, y) {</strong></p>
<p style="padding-left: 60px;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while true {}</strong></p>
<p style="padding-left: 60px;"><strong>&nbsp;&nbsp; } else {</strong></p>
<p style="padding-left: 60px;"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</strong></p>
<p style="padding-left: 60px;"><strong>&nbsp;&nbsp; }</strong></p>
<p style="padding-left: 60px;"><strong>}</strong></p>
<p style="padding-left: 60px;">This method, when applied to M and y, hangs if M and applied to y terminates, otherwise it returns.</p>
<ol start="3">
    <li>Next we turn this into a program<br /><br /> <strong>&nbsp; &nbsp; &nbsp;void doublehang (String y) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; haltcheck(y,y)<br />&nbsp; &nbsp; &nbsp;}</strong><br />&nbsp; &nbsp; &nbsp;This method, when applied to y (the body of a unary method), will hang if y applied to y terminates, otherwise it returns.<br /><br /></li>
    <li>Finally let z be the body of <strong>doublehang</strong>. We see that <strong>doublehang</strong>, when applied to z, terminates iff it hangs. Contradiction, hence the halting problem (for java) is (Java-)undecidable</li>
</ol>
<p>&nbsp;</p>
<h3 id="dec3"> Properties of code </h3>
<p>You can have any property such as Greenness (a method is green when, applied to any even integer, it returns an odd integer) then check whether methods are green.</p>
<p>For example the following method is green:</p>
<p>int jim (int x) {</p>
<p>&nbsp;&nbsp; if (x == 5) {</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;return 10;</p>
<p>&nbsp; &nbsp;} else if (x == 7) {</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;while (true) {}</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;return 8;</p>
<p>&nbsp; &nbsp;} else {</p>
<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;return 4*x + 7;</p>
<p>&nbsp; &nbsp;}</p>
<p>}</p>
<p>But the following method isn&rsquo;t green:</p>
<p>int alwayshang (int x) {</p>
<p>&nbsp;&nbsp;&nbsp; while (true) {}</p>
<p>&nbsp;&nbsp;&nbsp; return 13;</p>
<p>}&nbsp;</p>
<p>We can show that greenness is undecidable. For a nullary program P, let G(P) be the following method:</p>
<p>int gp (int x) {</p>
<p>&nbsp;&nbsp;&nbsp; P();</p>
<p>&nbsp;&nbsp;&nbsp; if (x == 5) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 10;</p>
<p>&nbsp;&nbsp;&nbsp; } else if (x == 7) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (true) {}</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 8;</p>
<p>&nbsp;&nbsp;&nbsp; } else {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 4*x + 7;</p>
<p>&nbsp;&nbsp;&nbsp; }</p>
<p>}</p>
<p>We can see that if P terminates then G(P) is green, whereas if P doesn&rsquo;t terminate then G(P) is not green. So if we can test for greenness, then we can test whether P terminates by testing whether G(P) is green. We can&rsquo;t test whether P terminates, so we can&rsquo;t test for greenness, i.e. greenness is undecidable</p>
<p>&nbsp;</p>
<p><strong>Semantic Properties</strong></p>
<p>If P terminates then G(P) is green. This is due to the methods G(P) and jim having the same semantics.</p>
<p>Int f (int x) {</p>
<p>&nbsp;&nbsp;&nbsp; &hellip;</p>
<p>}</p>
<p>Is the partial function from Z (the set of ints) to Z that it computes. Therefore, since jim is green, G(P) is too. If P hangs, then G(P) is not green. That&rsquo;s because G(P) and alwayshang have the same semantics (the empty partial function). Therefore since alwayshang isn&rsquo;t green, neither is G(P). We can summarize this all by saying greenness is a semantic property.</p>
<p>&nbsp;</p>
<h3 id="dec4"> Rice&rsquo;s Theorem </h3>
<p>Rice&rsquo;s Theorem: every nontrivial semantic property of code is undecidable</p>
<p>A trivial property is one that either holds of everything or holds of nothing</p>
<p>If we say that a method, such as:</p>
<p>int f (int x) {</p>
<p>&nbsp;&nbsp;&nbsp; ...</p>
<p>}</p>
<p>is yellow if, when applied to an integer n, it either hangs or returns an integer y that is a factor of 3y. Yellowness is a trivial property, because every method is yellow. Clearly every trivial property is decidable.</p>
<hr/>

<h2 id="tm"> 3 &ndash; Turing Machines </h2>
<p> <keyword>Turing Machines</keyword> are simple computers, except for their <keyword>infinite tape</keyword>. They can be said to be the simplest kind of computer that can be devised without sacrificing power. </p>
<img src="images/models/tm8.JPG"/>

<p> A Turing machine consists of finitely many states on a tape. The machine has a <keyword>head</keyword> that sits over one space of the tape. </p>
<ul>
    <li> Has an <keyword>alphabet</keyword> <em>T</em>. Each space contains one character from <em>T</em>.</li>
    <li> Has a <keyword>blank</keyword> &bbrk; character which is &bbrk; &isin; <em>T</em>. This represents <strong>all finite blank spaces</strong> on the tape.</li>
</ul>

<p> It is <em>never</em> the case that an <strong>infinite tape</strong> is filled with characters. Hence comes the <keyword>blank</keyword> &bbrk;. For this reason, we are only interested in the <keyword>part</keyword> of the tape that <keyword>has characters</keyword>. </p>

<p> This part of the tape must be <keyword>extendable</keyword> when required. But this would mean we have <strong>unlimited time and space</strong>, which is unrealistic in this world. Therefore a Turing Machine is an <keyword>idealised</keyword> computer.</p>

<h4> Definitions </h4>
<pre>
<keyword>T</keyword> &ndash; finite set of <em>tape alphabet</em>
<keyword>R</keyword> &ndash; finite set of <em>return values</em>

<keyword>Q</keyword> &ndash; finite set of states
<keyword><em>q<sub>o</sub></em></keyword> &isin; <keyword>Q</keyword> &ndash; initial state
<keyword>&delta;</keyword> &ndash; transition function from <keyword>Q</keyword> with these behaviors:
      (<keyword>T</keyword> &rightarrow; <keyword>Q</keyword>) - read from current position
    + (<keyword>T</keyword> &times; <keyword>Q</keyword>) - write to current position
          + <keyword>Q</keyword> - move left
          + <keyword>Q</keyword> - move right
          + <keyword>Q</keyword> - do nothing
          + <keyword>R</keyword> - stop
</pre>
<p> where: <br><code>+</code> means join by <keyword>Union &Union;</keyword>, <br><code>&rightarrow;</code> means <keyword>functions</keyword> from T to Q, <br><code>&times;</code> means the set of <keyword>ordered pairs</keyword> (t,q) &isin; (T &times; Q).</p>

<h3 id="tm1"> 3.1 &ndash; Example for Execution of Turing Machines </h3>
<h4> Example </h4>
<p> Design a Turing Machine that starts on the leftmost character of a non-empty block of a's & b's on an otherwise blank tape. </p>
<img src="images/models/tm2.JPG"/>
<p> And its execution will look like this: </p>
<img src="images/models/tm3.JPG"/>

<h3 id="tm2"> 3.2 &ndash; Examples for Designing a Turing Machine </h3>
<h4> Another Example 1 </h4>
<img src="images/models/tm1.JPG"/>

<h4 id="tmexample"> Another Example 2 </h4>
<p> Start on the leftmost character of a nonempty block of a's and b's on an otherwise blank tape. End on the space to right of block. Say whether the number of a's is even or odd. </p>
<img src="images/models/tm4.JPG"/>

<h3 id="tm3"> 3.3 &ndash; Macros </h3>
<p> <keyword>Macros</keyword> are a <strong>convenient notation</strong> for big machines. </p>
<h4> Yet Another Example </h4>
<p> Design a Turing Machine that starts on <em>leftmost</em> character of a block of a's and b's, and ends on <em>leftmost</em> character: </p>
<ul>
    <li> If the initial number of a's is <strong>even</strong> then change all a's to b's. </li>
    <li> Else leave the block <strong>unchanged</strong>. </li>
</ul>
<p> Note that we have already designed a machine <a href="#tmexample">above</a> which checks for <em>evenness</em>. Hence we can assign this as a macro: </p>
<img src="images/models/tm5.JPG"/>
<p> Because we have made a Turing Machine with <keyword>result set R</keyword>, we can then <strong>abbreviate</strong> it as a <strong>single instruction</strong> with <keyword>R outcomes</keyword>. </p>
<p> Thus, forming the solution: </p>
<img src="images/models/tm6.JPG"/>

<h4> Expanding Macros </h4>
<p> After formulating the machine above, we can then <keyword>expand the macro</keyword> to have the full Turing Machine by these steps: </p>
<ul>
    <li> <strong>Identify</strong> all <code>r &isin; R</code> (all elements in the result set),</li>
    <li> <keyword>Replace</keyword> all occurrence of <code>r &isin; R</code> with <code>No-op</code>,</li>
    <li> Connect this <code>No-op</code> with the rest of the main machine.</li>
</ul>
<p> And hence the final solution: </p>
<img src="images/models/tm7.JPG"/>

<p> Turing Machines are very convenient for analysing the <keyword>running time of algorithms</keyword>. </p>
<ul>
    <li> Time taken for an algorithm <strong>scales staightforwardly</strong> as the size of input increases.</li>
    <li> Every step of computation is made explicit in a very conservative way.</li>
</ul>

<h3 id="tm4"> 3.4 &ndash; Extension to Turing Machines </h3>





<h3 id="tm5"> 3.5 &ndash; Church's Thesis </h3>

<hr/>

<h2 id="comp"> 4 &ndash; Complexity </h2>



<hr/>

<h2 id="lambda"> Lambda Calculus </h2>
<p>&lambda;-calculus is a calculus of functions</p>
<p><em>"&lambda;x"</em> means <em>"the function that maps x to "</em></p>
<p>Juxtaposition means application</p>
<ul>
    <li>f x (as in OCaml and Haskell)</li>
</ul>
<p align="center"><img src="images/models/lambdasyntax.png" width="500"></p>
<p><strong>Precedence conventions</strong></p>
<ol>
    <li>Application has highest precedence</li>
    <li>* and /</li>
    <li>+ and -</li>
    <li>&lambda;x has lowest precedence</li>
</ol>
<p><strong>Application associates to the left</strong></p>
    <ul>
        <li>e.g. MNP should be bracketed as (MN)P</li>
        <li>e.g. (&lambda;x. &lambda;y. z x y) 15 12 implies ((&lambda;x. &lambda;y ((z x) y)) 15) 12</li>
    </ul>
<p>There are <strong>bound</strong> and <strong>free</strong> occurrences of variables</p>
<ul>
    <li>e.g. In (&lambda;x. &lambda;y. z x y) 15 12</li>
    <li>x and y are bound, but z is free</li>
</ul>
<p>An occurrence of a variable is bound to the innermost binder of that variable whose scope contains the occurrence</p>
<p>We say that terms are <strong>&alpha;-equivalent</strong> when they are the same, except for the binders and
    bound occurrences of variables, and these are bound to the same place</p>
<ul>
    <li>&alpha;-equivalent<ul>
        <li>&lambda;x. &lambda;x. &lambda;y. x+3</li>
        <li>&lambda;u. &lambda;v. &lambda;u. v+3</li>
    </ul></li>
    <li>Not &alpha;-equivalent (because free variables are different)<ul>
        <li>&lambda;x. &lambda;x. &lambda;y. x+z</li>
        <li>&lambda;u. &lambda;v. &lambda;u. v+w</li>
    </ul></li>
</ul>
<p>&alpha;-equivalent terms are regarded as the same</p>
<p><strong>Reduction of &lambda;-terms</strong></p>
<ul>
    <li><strong>&delta;-reductions</strong> (arithmetic)<ul>
        <li><u>m</u> + <u>n</u> &#8594; <u>m+n</u></li>
        <li>e.g. <u>5</u> + <u>7</u> &#8594; <u>12</u></li>
        <li><u>m</u> + <u>n</u> is a <strong>"&delta;-redex"</strong></li>
    </ul></li>
    <li><strong>&beta;-reductions</strong><ul>
        <li>(&lambda;x. M) N &#8594; M[N/x]<ul>
            <li>(&lambda;x. M) - "body" of the &lambda;-abstraction</li>
            <li>N - argument</li>
            <li>M[N/x] - M, where x is replaced by N</li>
        </ul></li>
        <li>e.g. (&lambda;x. x+3) 7 &#8594;<sub><em>&beta;</em></sub> 7 + 3 &#8594;<sub><em>&delta;</em></sub> 10</li>
        <li>(&lambda;x. M) N is a <strong>"&beta;-redex"</strong></li>
    </ul></li>
</ul>
<p>Substitution notes:</p>
<ul>
    <li>When we form M[N/x]<ul>
        <li>We replace only the <strong>free</strong> occurrences of x by N<ul>
            <li>i.e. in (&lambda;x. ((&lambda;x. x) 17) + x) 8</li>
        </ul></li>
        <li>The free variables in N must not be captured<ul>
            <li>i.e. in (&lambda;y. ((&lambda;x. x + y) 7) (x + 5)</li>
        </ul></li>
    </ul></li>
</ul>
<p> We stop evaluating when we reach a &beta;&delta;-normal form</p>
<ul>
    <li>i.e. a term that doesn't contain either a &beta;-redex or a &delta;-redex<ul>
        <li>e.g 23, x + 23, &lambda;x. x+23</li>
    </ul></li>
</ul>
<p>A term that has no free variables is called a <strong>closed term</strong>.</p>
<p><strong>Church-Rosser Theorem</strong></p>
<ul><li>If M &#8605;* N and M &#8605;* P then there exists Q such that N &#8605;* Q and P &#8605;* Q<ul>
    <li><em>M &#8605;* N means that M reduces to N in zero or more steps</em></li>
</ul></li></ul>
<p><strong>Corollary:</strong> Any term M has at most one &beta;&delta;-normal form</p>
<p><strong>Omega</strong></p>
<p>The term &Omega; is the following:</p>
<ul>
    <li>(&lambda;x. x x)(&lambda;x. x x) &#8605; (&lambda;x. x x)(&lambda;x. x x)</li>
    <li>The reduction graph is &Omega;&#8634;</li>
    <li>So &Omega; doesn't have a normal form</li>
</ul>
<p><strong>Types</strong></p>
<p>Types are a way of ruling out "badexes"</p>
<p>Examples of "badexes"</p>
<ul>
    <li>&lambda;x. M + <u>n</u></li>
    <li><u>n</u> + &lambda;x. M</li>
    <li>&lambda;x. M + &lambda;x. M'</li>
    <li><u>n</u> M</li>
</ul>
<p>They're correct terms of <strong>untyped</strong> &lambda;-calculus. So is &Omega;</p>
<p><strong>Typed &lambda;-calculus with arithmetic</strong></p>
<p><u>Syntax of types</u><br>
<div align="center">A ::= int | A &#8594; A | (A)</div>
<ul>
    <li>i.e. int &#8594; int is the type of functions that take an integer argument and return an integer</li>
</ul>
<p><strong>Convention:</strong> &#8594; associates to the right</p>
<ul><li> int &#8594; int &#8594; int </li>
<li>Implicit bracketing is int &#8594; (int &#8594; int)</li></ul>
<p>Here is a term of <strong>untyped</strong> &lambda;-calc with arithmetic</p>
<p>Example 1:</p>
<p align="center"><strong>&lambda;x. x<u>3</u> + <u>7</u></strong></p>
<p>Annotate this with <strong>types</strong> by looking for clues</p>
<ul>
    <li><strong>Clue 1:</strong> x is applied to something. So has type A &#8594; B</li>
    <li><strong>Clue 2:</strong> The thing it's applied to, which has type A, is an integer. So A = int</li>
    <li><strong>Clue 3:</strong> x<u>3</u>, which has type B, gets added to something. So B = int</li>
    <li><strong>Conclusion:</strong> x has type int &#8594; int</li>
</ul>
<p>Annotated term:</p>
<p align="center"><strong>&lambda;x: int &#8594; int. x<u>3</u> + <u>7</u></strong></p>
<p>Example 2:</p>
<p align="center"><strong>&lambda;x. &lambda;y. x(xy) + <u>17</u></strong></p>
<p>Look for the clues</p>
<ul>
    <li><strong>Clue 1:</strong> x is applied to something. So x has type A &#8594; B</li>
    <li><strong>Clue 2:</strong> x is applied to y. So y has type A</li>
    <li><strong>Clue 3:</strong> x is applied to xy, which has type B. So A = B</li>
    <li><strong>Clue 4:</strong> x(xy), which has type B, is added to something. So B = int</li>
    <li><strong>Conclusion:</strong> x has type int &#8594; int and y has type int</li>
</ul>
<p>Annotated term:</p>
<p align="center"><strong>&lambda;x: int &#8594; int. &lambda;y: int. x(xy) + <u>17</u></strong></p>
<p>This has type (int &#8594; int) &#8594; (int &#8594; int) <br> or just (int &#8594; int) &#8594; int &#8594; int</p>
<p>Example 3:</p>
<p align="center"><strong>(&lambda;x. <u>3</u>)(<u>17</u> &lambda;y. y)</strong></p>
<ul>
    <li><u>17</u> has type A &#8594; B because it's applied to something, but also has type int. <strong>
        Contradiction
    </strong> </li>
</ul>
<p>Example 4:</p>
<p align="center"><strong>(&lambda;x. x x)(&lambda;y. y y)</strong></p>
<ul>
    <li><strong>Clue 1:</strong> x gets applied to something, so it has type A &#8594; B </li>
    <li><strong>Clue 2:</strong> x gets applied to x, so A = A &#8594; B</li>
</ul>
<p>So A is:</p>
<p align="center">(( ... &#8594; B) &#8594; B) &#8594; B</p>
<p>But all out type expression are finite. <strong>Contradiction.</strong></p>
<p>Example 5:</p>
<p align="center"><strong>&lambda;x. x <u>7</u></strong></p>
<ul>
    <li><strong>Clue 1:</strong> x is applied to something, so it has type A &#8594; B</li>
    <li><strong>Clue 2:</strong> x is applied to <u>7</u>, which has type int, so A = int</li>
    <li><strong>Conclusion:</strong> x has type int &#8594; B</li>
</ul>
<p>Most general solution:</p>
<p align="center"><strong>&lambda;x: int &#8594; B. x <u>7</u></strong></p>
<p>which has type:</p>
<p align="center"><strong>(int &#8594; B) &#8594; B</strong></p>
<p><strong>Multi-ary Functions</strong></p>
<p>In &lambda;-calculus, all functions are <strong>unary</strong>. i.e. They take just 1 argument</p>
<p>We use <strong>currying</strong> to express <strong>multi-ary</strong> functions in &lambda;-calculus</p>
<p>We represent a function with two arguments as a function that returns a function. <br> Say we want the function that
takes arguments x:int and y:int and returns x + 17 * y<br> We represent it as:</p>
<p align="center">&lambda;x: int. &lambda;y: int. x + 17 * y</p>
<p>which has type</p>
<p align="center">int &#8594; (int &#8594; int)</p>
<p align="center">(&lambda;f: int &#8594; (int &#8594; int). (f 5) 2) (&lambda;x: int. &lambda;y: int. x + 17 * y) </p>
<p>This is the reason for the conventions:</p>
<ul>
    <li>&#8594; associates to the right</li>
    <li>Application associates to the left</li>
</ul>
<p>We also use Currying in untyped &lambda;-calculus</p>
<p>(&lambda;f. f 5 2)(&lambda;x. &lambda;y. x + 17 * y)<br>
    &#8605; (&lambda;x. &lambda;y. x + 17 * y) 5 2 <br>
    &#8605; (&lambda;y. 5 + 17 * y) 2 <br>
    &#8605; 5 + 17 * 2 <br>
    &#8605; 5 + 34 <br>
    &#8605; 39</p>

<p><strong>Advantages of Types</strong></p>
<ul>
    <li>There are no terms that evaluate to a "badex".<ul>
        <li><strong>Well-typed programs don't get stuck!</strong></li>
        <li>Programmers' mistakes can be caught at compile-time</li>
    </ul></li>
    <li>No terms that run forever<ul>
        <li><strong>Theorem: Strong Normalisation</strong></li>
        <li>There is no infinite sequence of reductions M<sub>0</sub> &#8605; M<sub>1</sub>
            &#8605; M<sub>2</sub> &#8605; M<sub>3</sub> &#8605; ... for typed &lambda;-calculus with arithmetic</li>
        <li>We often, however, want to extend typed &lambda;-calculus with features that allows terms to run forever e.g.
        recursion or iteration (such as a while loop)</li>
    </ul></li>
    <li>Typed terms have a meaning<ul>
        <li>The meaning of &lambda;x: int. x is the identity function &#8484; &#8594; &#8484; </li>
        <li>The meaning of &lambda;x: bool. x is the identity function &#120121; &#8594; &#120121;</li>
        <li>The meaning of &lambda;x. x is problematic</li>
    </ul></li>
</ul>
<p><strong>Disadvantages of Types</strong></p>
<ul>
    <li>Types rule out useful programs<ul>
        <li>Example: in untyped &lambda;-calculus<ul>
            <li>
                (&lambda;f. (f &lambda;x. x)(f <u>3</u>)) &lambda;y. y <br>
                &#8605; ((&lambda;y. y)(&lambda;x. x))((&lambda;y.y)<u>3</u>) <br>
                &#8605; (&lambda;x. x)((&lambda;y. y) <u>3</u>) <br>
                &#8605; (&lambda;x. x) <u>3</u> <br>
                &#8605; 3
            </li>
        </ul></li>
        <li><strong>Clue 1:</strong> f is applied to something, so it has type A &#8594; B</li>
        <li><strong>Clue 2:</strong> f is applied to <u>3</u> so A = int</li>
        <li><strong>Clue 3:</strong> f is applied to &lambda;x.x so A = C &#8594; D</li>
        <li>To allow terms like this example, we need a fancier type system. (Specifically a polymorphic system)</li>
        <li>But no matter how fancy the type system, there will always be legitimate terms that are rules out.</li>
        <li>This is because whether a term is safe (i.e. avoids badexes, avoids running forever) is undecidable and
            compilers always have to terminate</li>
        <li>Some languages have a compromise solution: types are present most of the time, but in rare situations the type
        discipline can be ignored</li>
    </ul></li>
</ul>

<hr/>

<h2 id="papers"> Past Papers </h2>

<hr/>
<!-- Utils -->
<button onclick="topFunction()" id="topBtn" title="Go to top">Top</button>
<script>
    // When the user scrolls down 20px from the top of the document, show the button
    window.onscroll = function() {scrollFunction()};

    function scrollFunction() {
        if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
            document.getElementById("topBtn").style.display = "block";
        } else {
            document.getElementById("topBtn").style.display = "none";
        }
    }

    // When the user clicks on the button, scroll to the top of the document
    function topFunction() {
        document.body.scrollTop = 0;
        document.documentElement.scrollTop = 0;
    }
</script>
<button onclick="window.location.href='index.html'" id="homeBtn" title="Back to Home"> Home </button>

</body>
</html>