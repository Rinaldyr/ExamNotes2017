<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title> Models of Computation </title>
    <style type="text/css">
        body {
            background-color: #fbffd8;
            font-family: "Georgia", serif;
        }

        ol > li {
            margin: 10px;
        }

        #topBtn {
            display: none;
            position: fixed;
            bottom: 80px;
            right: 20px;
            z-index: 99;
            border: none;
            outline: none;
            background-color: red;
            color: white;
            cursor: pointer;
            padding: 15px;
            border-radius: 10px;
        }

        #topBtn:hover {
            background-color: #555;
        }

        #homeBtn {
            display: block;
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 99;
            border: none;
            outline: none;
            background-color: red;
            color: white;
            cursor: pointer;
            padding: 15px;
            border-radius:10px;
        }

        #homeBtn:hover {
            background-color: #555;
        }
    </style>
</head>
<body>
<hr/>
<h1> LI Models of Computation </h1>
<hr/>
Table of Contents
<ol>
    <li> <a href="#fsa"> Language and Automata </a> <ul>
        <li> <a href="#fsa1"> Problems and Computers </a> </li>
        <li> <a href="#fsa2"> Regular Expression </a> </li>
        <li> <a href="#fsa3"> Finite State Automaton</a> </li>
        <li> <a href="#fsa4"> Bisimulation </a> </li>
    </ul> </li>
    <li> <a href="#dec"> Decidability </a> <ul>
        <li> <a href="#dec1"> Decision Problems </a> </li>
        <li> <a href="#dec2"> The Halting Theorem </a> </li>
        <li> <a href="#dec3"> Properties of Code </a> </li>
    </ul></li>
    <li> <a href="#tm"> Turing Machines </a> <ul>
        <li> <a href="#tm1"> Executing TMs </a> </li>
        <li> <a href="#tm2"> Designing TMs </a> </li>
        <li> <a href="#tm3"> Extensions of TMs </a> </li>
        <li> <a href="#tm4"> Church's Thesis </a> </li>
    </ul></li>
    <li> <a href="#comp"> Complexity </a> <ul>
        <li> <a href="#comp1"> Complexity of Algorithms </a> </li>
        <li> <a href="#comp2"> Complexity of Problems </a> </li>
        <li> <a href="#comp3"> O notation </a> </li>
        <li> <a href="#comp4"> NP Problems </a> </li>
        <li> <a href="#comp5"> NP-complete Problems </a> </li>
        <li> <a href="#comp6"> Satisfiability </a> </li>
    </ul></li>
    <li> <a href="#lambda"> Lambda Calculus </a> <ul>
        <li> <a href="#lambda1"> Lambda Application </a> </li>
        <li> <a href="#lambda2"> Evaluating Expressions </a> </li>
        <li> <a href="#lambda3"> Typed Lambda Calculus </a> </li>
        <li> <a href="#lambda4"> Typed vs Untyped </a> </li>
    </ul></li>
    <li> <a href="#papers"> Past Papers </a> </li>
</ol>

<hr/>

<h3 id="fsa"> Languages and Automata </h3>
<h4 id="fsa1"> Problems and Computers </h4>
<p> <em> This module is about problems and computers, except for the last part which is about &lambda;-calculus. </em> </p>

<p> Some questions that we can ask ourselves: </p>
<ul>
    <li> What problems can be solved on a computer? </li>
    <li> What problems can be solved on a computer with only finitely many states? </li>
    <li> What problems can be solved <em> fast </em> on a computer? </li>
    <li> What does "fast" mean anyway? </li>
    <li> What does "computer" mean anyway? </li>
    <li> etc.. </li>
</ul>

<h4> Language Membership Problems </h4>
Suppose that we have a set of characters, the alphabet &Sigma;. <br/>
A word (or string) is a finite sequence of characters. <br/> We write &Sigma;* for the set of all words. We can concatenate words. <br/>
The empty word is written as &epsilon;. <br/>
A language is a set of words, which means that it is a subset of &Sigma;*. <br/>

<p> Example language 1 <br/>
    Let's say the alphabet is {a,b,c}. The image below shows some example languages: <br/>
    <img src="images/models/fsa1.JPG"/> <br/>
    This can be applicable in real-life situations such as: <br/>
    <img src="images/models/fsa2.JPG"/> <br/>
    In all of these examples, somebody has provided a word and we want to know whether it is an acceptable word. Ideally, we want a computer program that will tell us. </p>

<h4 id="fsa2"> Regular Expressions </h4>
<p> Every regular expression gives rise to a language &ndash; a <em> regular language </em>. Some useful notations for describing languages: </p>
<ul>
    <li> We write <em> Empty </em> for the language consisting of no words, or the empty set. </li>
    <li> We write <em> a </em> for the language consisting of the single-character word <em> a </em> </li>
    <li> We write &epsilon; for the language consisting of just the empty word. </li>
    <li> Suppose <em> L </em> and <em> L' </em> are languages. <ul>
        <li> We write <em> LL' </em> for the set of words that are a concatenation of a word in <em> L </em> and a word in <em> L' </em> </li>
        <li> We write <em> L | L'</em> for the set of words that are either in <em> L </em> or <em> L' </em>. This is basically the union of <em> L </em> and <em> L' </em>. </li>
        <li> We write <em> L* </em> for the set of words that are a concatenation of some number of words in <em> L </em>. Note that "some number" might be 0, so the empty word is in <em> L* </em>. </li>
    </ul> </li>
</ul>
<p> All expressions built up this way makes a regular expression. A regular expression <em> E </em> can be either Empty, &epsilon;, <em> a, b c, </em> or anything in the alphabet, <em> EE' </em>, <em> E | E' </em>, or <em> E* </em>. </p>

<p> Just like arithmetic expressions, you can't make sense of regular expressions without knowing the precedence rules. <em> * </em> has the highest precedence, then juxtaposition (putting things next to each other, you juxtapose AB in algebra means A * B, or <strong> concatenation</strong>) then |.</p>

<p style="font-weight: bold"> Example exercises </p>
<ol>
    <li> Is the word <em> abb </em> in the language <em> a(b|c)* </em> ? &emsp; <span style="border: 1px solid darkgoldenrod;" onmouseenter="this.innerHTML='Yes, because a matches then b then b since (b|c)*'"> Hover for answer </span> </li>

    <li> Is the word <em> abc </em> in the language <em> a(b|c)* </em> ? &emsp; <span style="border: 1px solid darkgoldenrod;" onmouseenter="this.innerHTML='Yes, because a matches then b then c since (b|c)*'"> Hover for answer </span> </li>

    <li> Is the word <em> aabbab </em> in the language <em> (a(b|c)*)* </em> ? &emsp; <span style="border: 1px solid darkgoldenrod;" onmouseenter="this.innerHTML='Yes, because a abb ab'"> Hover for answer </span> </li>

    <li> Is the word <em> abbabca </em> in the language <em> (ab|ba)* </em> ? &emsp; <span style="border: 1px solid darkgoldenrod;" onmouseenter="this.innerHTML='No, because c is not in the language'"> Hover for answer </span> </li>

    <li> is the language <em> ((a|b)(b|c))* </em> the same as the language <em> (ab|ac|bb|bc)* </em> ? &emsp; <span style="border: 1px solid darkgoldenrod;" onmouseenter="this.innerHTML='Yes, because they are can form either ab or ac or bb or bc, then * the whole thing'"> Hover for answer </span> </li>

    <li> For each regexp <em> E </em>, could you write a program that takes a word <em> w </em> and says whether it's in the language represented by E? &emsp; <span style="border: 1px solid darkgoldenrod;" onmouseenter="this.innerHTML='Yes, a very efficient one'"> Hover for answer </span> </li>

    <li> Could you write a single program that takes a word <em> w </em> and a regexp <em> E </em> and says whether <em> w </em> is in the language represented by <em> E </em> ? &emsp; <span style="border: 1px solid darkgoldenrod;" onmouseenter="this.innerHTML='Yes'"> Hover for answer </span> </li>

    <li> Could you write a program that takes two regexps and says whether they represent the same language? &emsp; <span style="border: 1px solid darkgoldenrod;" onmouseenter="this.innerHTML='Yes, but it is not obvious'"> Hover for answer </span> </li>
</ol>

<p> Regular expression in theoretical computer science means an expression built up from the above operations and nothing more. The term has come to be used in Linux etc. to include various other operations. Regexps are also used in a somewhat different sense to find occurrences of words within a larger word. </p>

<p> <strong> Kleene's theorem </strong> says a language is regular (i.e. recognized by a regular expression) if and only if it is accepted by a finite state automaton. </p>

<p> Here are a few common abbreviations, it is optional to use these. <br/> <img src="images/models/fsa3.JPG"/> </p>


<h3 id="fsa3"> Finite State Automaton </h3>
<p> A finite state automaton over &Sigma; is </p>
<ul>
    <li> a finite set &Qopf; of states (<em> nodes </em>) </li>
    <li> a transition function &Qopf; &times; &Sigma; &rightarrow; &Qopf; (<em> paths, edges </em>) </li>
    <li> a set Acc &subseteq; &Qopf; of accepting states (<em> double nodes </em>) </li>
    <li> an initial state <em> q<sub>0</sub> </em> &epsi; &Qopf; (<em> diamond node </em>) </li>
</ul>
<p> Every finite state automaton has an associated language. To convert a partial FSA into a complete FSA, simply add an error state. </p>

<p> <span style="font-weight: bold;"> Removing &epsilon;-transitions </span> <br/> There's a <em> slow a-transition </em> from state q to state q' when, starting from state q we can follow some number of &epsilon;-transition, and end in state q'. A state q is <em> slowly accepting </em> when, starting from state q we can follow some number of &epsilon;-transitions and reach an accepting state. </p>

<p> But if we want to remove all &epsilon;-transitions, we keep the set of states, keep the initial state, replace the slow transitions by transitions, and replace slowly accepting states by accepting states. After removing all &epsilon;-transitions, we will obtain a Non-Deterministic Finite Automaton (NDFA). </p>

<p> <span style="font-weight: bold;"> Determinisation </span> <br/> Given a NDFA, we can form a Deterministic Finite Automaton (DFA) by first having the states a subset of &Qopf;, then from a state U &subseteq; &Qopf;, when we input a, take the set of all states that we can reach by an a-transition from a state in U. An accepting state is any that contains a state in Acc. The initial state is {<em>q<sub>0</sub></em>}. </p>

<p> <span style="font-weight: bold;"> Converting a regexp into a DFA </span> <br/> Convert first into NDFA by removing &epsilon;-transitions, and then determinise as mentioned above. </p>

<p> <span style="font-weight: bold;"> Converting DFA into a regexp </span> <br/> So say we have states {0,1,...,<em>n</em> &ndash; 1}. <br/> For any state <em>i</em> and <em>j</em> and any <em>k &le; n</em>, we want a regexp <em> E <span style="position: relative; top: 0.5em; left: -0.3em;"> <em> i&rightarrow;j</em></span> <span style="position:relative; top: -0.5em; left: -1.8em;"> &lt;k </span> </em> <br/> that accepts those words that take us from <em>i</em> and <em>j</em> with intermediate states all &lt; <em>k</em>. <br/>
    The image below shows the formula to convert DFA into a regexp. <br/> <br/> <img src="images/models/fsa4.JPG"/> </p>

<p> <em> Note: Every node in NDFA will always have equal number of transitions, and that number is all the possible transitions, and each of them are labelled with sets of states. </em> </p>

<p> <span style="font-weight: bold;"> Operations on Regular Languages </span> <br/> We can use Kleene's theorem to prove that some languages are regular. Firstly, the complement of a regular language L is regular. <br/> The proof is to get a DFA that recognises L, and by Kleene's theorem, the new complement automaton will have accepting states that are the set &Qopf;\Acc. This recognises the complement of L, so the latter is regular. <br/> The intersection of regular languages L and L' is regular (Corollary), because it's the complement of the union of the complements L and L' by Kleene's theorem. If L and L' are regular, then L \ L' is regular because L &cap; (&Sigma; \ L') by corollary. </p>

<p> <span style="font-weight: bold;"> Proving a language is not regular </span> <br/> We can prove this by finding an L-distinguishing suffix for words. Suppose we have a DFA that recognises the language L. And if we have words that have an L-distinguishing suffix, then each word must take us from the initial state to different states. <br/>
    If there is a countable sequence of distinctive words, then the minimum states of the DFA will be equal to the size of the set. <br/>
    However, if it is an infinite sequence of distinctive words, then there will be no DFA, and by Kleene's theorem the language is not regular. (<em>Myhill-Nerode Theorem</em>)<br/> </p>
<p> Also by the use of <strong> pumping lemma</strong>, which says that for any regular language L there exists a constant p such that any word w in L with length at least p can eb split into three substrings, w = xyz, where the middle portion of y must not be empty, such that the words xz, xyz, xyyz, xyyyz, ... constructed by repeating y zero or more times are still in L. The repetition process is called "pumping". Moreover, the pumping lemma guarantees that the length of xy will be at most p, imposing a limit on the way in which w may be split. Finite languages trivially satisfy the pumping lemma by having p equal to the maximum string length in L plus one. </p>

<h4 id="fsa4"> Bisimulation </h4>
<p> An <em> unpointed automaton </em> is one that has no initial state. <br/> A <strong> bisimulation </strong> between unpointed total deterministic automata (&Qopf;, &sigma;, Acc) and (&Qopf;', &sigma;', Acc') with the same alphabet L is a relation R &subseteq; &Qopf; &times; &Qopf;' such that if <em> qRq' </em> and a &epsi; L then &sigma;(q,a)R&sigma;'(q',a), and if <em> qRq' </em> then q &epsi; Acc iff q' &epsi; Acc'. <br/>
    Suppose that we have to unpointed automata for the same alphabet L. Then a state <em>q<sub>0</sub></em> &epsi; Q is bisimilar to a state <em>q'<sub>0</sub></em> if and only if they accept the same language. To prove this, show that for any word <em> w </em>, if <em>qRq'</em> then <em> q </em> accepts <em> w </em> if and only if <em> q' </em> accepts <em> w</em>. This is by induction on <em> w</em>. </p>

<p> The theorem is that two states accept the same language iff they are bisimilar. </p>

<h4 id="fsa5"> Minimisation </h4>
<p> To minimise an automaton means to throw away unreachable states and to identify bisimilar states. </p>
<ol>
    <li> Draw a table for all pairs of states (P,Q) </li>
    <li> Mark all pairs where P &in; Acc and Q &notin; Acc </li>
    <li> If there are any unmarked pairs (P,Q) such that transitions [&sigma;(P,x), &sigma;(Q,x)] is marked, then mark [P,Q] where 'x' is an input symbol. Repeat this until no more markings can be made. </li>
    <li> Combine all the unmarked pairs and make them a single state in the minimised DFA </li>
</ol>

<hr/>

<h3 id="dec"> Decidability </h3>

<hr/>

<h3 id="tm"> Turing Machines </h3>

<hr/>

<h3 id="comp"> Complexity </h3>

<hr/>

<h3 id="lambda"> Lambda Calculus </h3>
<p>&lambda;-calculus is a calculus of functions</p>
<p><em>"&lambda;x"</em> means <em>"the function that maps x to "</em></p>
<p>Juxtaposition means application</p>
<ul>
    <li>f x (as in OCaml and Haskell)</li>
</ul>
<p align="center"><img src="images/models/lambdasyntax.png" width="500"></p>
<p><strong>Precedence conventions</strong></p>
<ol>
    <li>Application has highest precedence</li>
    <li>* and /</li>
    <li>+ and -</li>
    <li>&lambda;x has lowest precedence</li>
</ol>
<p><strong>Application associates to the left</strong></p>
    <ul>
        <li>e.g. MNP should be bracketed as (MN)P</li>
        <li>e.g. (&lambda;x. &lambda;y. z x y) 15 12 implies ((&lambda;x. &lambda;y ((z x) y)) 15) 12</li>
    </ul>
<p>There are <strong>bound</strong> and <strong>free</strong> occurrences of variables</p>
<ul>
    <li>e.g. In (&lambda;x. &lambda;y. z x y) 15 12</li>
    <li>x and y are bound, but z is free</li>
</ul>
<p>An occurrence of a variable is bound to the innermost binder of that variable whose scope contains the occurrence</p>
<p>We say that terms are <strong>&alpha;-equivalent</strong> when they are the same, except for the binders and
    bound occurrences of variables, and these are bound to the same place</p>
<ul>
    <li>&alpha;-equivalent<ul>
        <li>&lambda;x. &lambda;x. &lambda;y. x+3</li>
        <li>&lambda;u. &lambda;v. &lambda;u. v+3</li>
    </ul></li>
    <li>Not &alpha;-equivalent (because free variables are different)<ul>
        <li>&lambda;x. &lambda;x. &lambda;y. x+z</li>
        <li>&lambda;u. &lambda;v. &lambda;u. v+w</li>
    </ul></li>
</ul>
<p>&alpha;-equivalent terms are regarded as the same</p>
<p><strong>Reduction of &lambda;-terms</strong></p>
<ul>
    <li><strong>&delta;-reductions</strong> (arithmetic)<ul>
        <li><u>m</u> + <u>n</u> &#8594; <u>m+n</u></li>
        <li>e.g. <u>5</u> + <u>7</u> &#8594; <u>12</u></li>
        <li><u>m</u> + <u>n</u> is a <strong>"&delta;-redex"</strong></li>
    </ul></li>
    <li><strong>&beta;-reductions</strong><ul>
        <li>(&lambda;x. M) N &#8594; M[N/x]<ul>
            <li>(&lambda;x. M) - "body" of the &lambda;-abstraction</li>
            <li>N - argument</li>
            <li>M[N/x] - M, where x is replaced by N</li>
        </ul></li>
        <li>e.g. (&lambda;x. x+3) 7 &#8594;<sub><em>&beta;</em></sub> 7 + 3 &#8594;<sub><em>&delta;</em></sub> 10</li>
        <li>(&lambda;x. M) N is a <strong>"&beta;-redex"</strong></li>
    </ul></li>
</ul>
<p>Substitution notes:</p>
<ul>
    <li>When we form M[N/x]<ul>
        <li>We replace only the <strong>free</strong> occurrences of x by N<ul>
            <li>i.e. in (&lambda;x. ((&lambda;x. x) 17) + x) 8</li>
        </ul></li>
        <li>The free variables in N must not be captured<ul>
            <li>i.e. in (&lambda;y. ((&lambda;x. x + y) 7) (x + 5)</li>
        </ul></li>
    </ul></li>
</ul>
<p> We stop evaluating when we reach a &beta;&delta;-normal form</p>
<ul>
    <li>i.e. a term that doesn't contain either a &beta;-redex or a &delta;-redex<ul>
        <li>e.g 23, x + 23, &lambda;x. x+23</li>
    </ul></li>
</ul>
<p>A term that has no free variables is called a <strong>closed term</strong>.</p>
<p><strong>Church-Rosser Theorem</strong></p>
<ul><li>If M &#8605;* N and M &#8605;* P then there exists Q such that N &#8605;* Q and P &#8605;* Q<ul>
    <li><em>M &#8605;* N means that M reduces to N in zero or more steps</em></li>
</ul></li></ul>
<p><strong>Corollary:</strong> Any term M has at most one &beta;&delta;-normal form</p>
<p><strong>Omega</strong></p>
<p>The term &Omega; is the following:</p>
<ul>
    <li>(&lambda;x. x x)(&lambda;x. x x) &#8605; (&lambda;x. x x)(&lambda;x. x x)</li>
    <li>The reduction graph is &Omega;&#8634;</li>
    <li>So &Omega; doesn't have a normal form</li>
</ul>
<p><strong>Types</strong></p>
<p>Types are a way of ruling out "badexes"</p>
<p>Examples of "badexes"</p>
<ul>
    <li>&lambda;x. M + <u>n</u></li>
    <li><u>n</u> + &lambda;x. M</li>
    <li>&lambda;x. M + &lambda;x. M'</li>
    <li><u>n</u> M</li>
</ul>
<p>They're correct terms of <strong>untyped</strong> &lambda;-calculus. So is &Omega;</p>
<p><strong>Typed &lambda;-calculus with arithmetic</strong></p>
<p><u>Syntax of types</u><br>
<div align="center">A ::= int | A &#8594; A | (A)</div></p>
<ul>
    <li>i.e. int &#8594; int is the type of functions that take an integer argument and return an integer</li>
</ul>
<p><strong>Convention:</strong> &#8594; associates to the right</p>
<ul><li> int &#8594; int &#8594; int </li>
<li>Implicit bracketing is int &#8594; (int &#8594; int)</li></ul>
<p>Here is a term of <strong>untyped</strong> &lambda;-calc with arithmetic</p>
<p>Example 1:</p>
<p align="center"><strong>&lambda;x. x<u>3</u> + <u>7</u></strong></p>
<p>Annotate this with <strong>types</strong> by looking for clues</p>
<ul>
    <li><strong>Clue 1:</strong> x is applied to something. So has type A &#8594; B</li>
    <li><strong>Clue 2:</strong> The thing it's applied to, which has type A, is an integer. So A = int</li>
    <li><strong>Clue 3:</strong> x<u>3</u>, which has type B, gets added to something. So B = int</li>
    <li><strong>Conclusion:</strong> x has type int &#8594; int</li>
</ul>
<p>Annotated term:</p>
<p align="center"><strong>&lambda;x: int &#8594; int. x<u>3</u> + <u>7</u></strong></p>
<p>Example 2:</p>
<p align="center"><strong>&lambda;x. &lambda;y. x(xy) + <u>17</u></strong></p>
<p>Look for the clues</p>
<ul>
    <li><strong>Clue 1:</strong> x is applied to something. So x has type A &#8594; B</li>
    <li><strong>Clue 2:</strong> x is applied to y. So y has type A</li>
    <li><strong>Clue 3:</strong> x is applied to xy, which has type B. So A = B</li>
    <li><strong>Clue 4:</strong> x(xy), which has type B, is added to something. So B = int</li>
    <li><strong>Conclusion:</strong> x has type int &#8594; int and y has type int</li>
</ul>
<p>Annotated term:</p>
<p align="center"><strong>&lambda;x: int &#8594; int. &lambda;y: int. x(xy) + <u>17</u></strong></p>
<p>This has type (int &#8594; int) &#8594; (int &#8594; int) <br> or just (int &#8594; int) &#8594; int &#8594; int</p>
<p>Example 3:</p>
<p align="center"><strong>(&lambda;x. <u>3</u>)(<u>17</u> &lambda;y. y)</strong></p>
<ul>
    <li><u>17</u> has type A &#8594; B because it's applied to something, but also has type int. <strong>
        Contradiction
    </strong> </li>
</ul>
<p>Example 4:</p>
<p align="center"><strong>(&lambda;x. x x)(&lambda;y. y y)</strong></p>
<ul>
    <li><strong>Clue 1:</strong> x gets applied to something, so it has type A &#8594; B </li>
    <li><strong>Clue 2:</strong> x gets applied to x, so A = A &#8594; B</li>
</ul>
<p>So A is:</p>
<p align="center">(( ... &#8594; B) &#8594; B) &#8594; B</p>
<p>But all out type expression are finite. <strong>Contradiction.</strong></p>
<p>Example 5:</p>
<p align="center"><strong>&lambda;x. x <u>7</u></strong></p>
<ul>
    <li><strong>Clue 1:</strong> x is applied to something, so it has type A &#8594; B</li>
    <li><strong>Clue 2:</strong> x is applied to <u>7</u>, which has type int, so A = int</li>
    <li><strong>Conclusion:</strong> x has type int &#8594; B</li>
</ul>
<p>Most general solution:</p>
<p align="center"><strong>&lambda;x: int &#8594; B. x <u>7</u></strong></p>
<p>which has type:</p>
<p align="center"><strong>(int &#8594; B) &#8594; B</strong></p>
<p><strong>Multi-ary Functions</strong></p>
<p>In &lambda;-calculus, all functions are <strong>unary</strong>. i.e. They take just 1 argument</p>
<p>We use <strong>currying</strong> to express <strong>multi-ary</strong> functions in &lambda;-calculus</p>
<p>We represent a function with two arguments as a function that returns a function. <br> Say we want the function that
takes arguments x:int and y:int and returns x + 17 * y<br> We represent it as:</p>
<p align="center">&lambda;x: int. &lambda;y: int. x + 17 * y</p>
<p>which has type</p>
<p align="center">int &#8594; (int &#8594; int)</p>
<p align="center">(&lambda;f: int &#8594; (int &#8594; int). (f 5) 2) (&lambda;x: int. &lambda;y: int. x + 17 * y) </p>
<p>This is the reason for the conventions:</p>
<ul>
    <li>&#8594; associates to the right</li>
    <li>Application associates to the left</li>
</ul>
<p>We also use Currying in untyped &lambda;-calculus</p>
<p>(&lambda;f. f 5 2)(&lambda;x. &lambda;y. x + 17 * y)<br>
    &#8605; (&lambda;x. &lambda;y. x + 17 * y) 5 2 <br>
    &#8605; (&lambda;y. 5 + 17 * y) 2 <br>
    &#8605; 5 + 17 * 2 <br>
    &#8605; 5 + 34 <br>
    &#8605; 39</p>

<p><strong>Advantages of Types</strong></p>
<ul>
    <li>There are no terms that evaluate to a "badex".<ul>
        <li><strong>Well-typed programs don't get stuck!</strong></li>
        <li>Programmers' mistakes can be caught at compile-time</li>
    </ul></li>
    <li>No terms that run forever<ul>
        <li><strong>Theorem: Strong Normalisation</strong></li>
        <li>There is no infinite sequence of reductions M<sub>0</sub> &#8605; M<sub>1</sub>
            &#8605; M<sub>2</sub> &#8605; M<sub>3</sub> &#8605; ... for typed &lambda;-calculus with arithmetic</li>
        <li>We often, however, want to extend typed &lambda;-calculus with features that allows terms to run forever e.g.
        recursion or iteration (such as a while loop)</li>
    </ul></li>
    <li>Typed terms have a meaning<ul>
        <li>The meaning of &lambda;x: int. x is the identity function &#8484; &#8594; &#8484; </li>
        <li>The meaning of &lambda;x: bool. x is the identity function &#120121; &#8594; &#120121;</li>
        <li>The meaning of &lambda;x. x is problematic</li>
    </ul></li>
</ul>
<p><strong>Disadvantages of Types</strong></p>
<ul>
    <li>Types rule out useful programs<ul>
        <li>Example: in untyped &lambda;-calculus<ul>
            <li>
                (&lambda;f. (f &lambda;x. x)(f <u>3</u>)) &lambda;y. y <br>
                &#8605; ((&lambda;y. y)(&lambda;x. x))((&lambda;y.y)<u>3</u>) <br>
                &#8605; (&lambda;x. x)((&lambda;y. y) <u>3</u>) <br>
                &#8605; (&lambda;x. x) <u>3</u> <br>
                &#8605; 3
            </li>
        </ul></li>
        <li><strong>Clue 1:</strong> f is applied to something, so it has type A &#8594; B</li>
        <li><strong>Clue 2:</strong> f is applied to <u>3</u> so A = int</li>
        <li><strong>Clue 3:</strong> f is applied to &lambda;x.x so A = C &#8594; D</li>
        <li>To allow terms like this example, we need a fancier type system. (Specifically a polymorphic system)</li>
        <li>But no matter how fancy the type system, there will always be legitimate terms that are rules out.</li>
        <li>This is because whether a term is safe (i.e. avoids badexes, avoids running forever) is undecidable and
            compilers always have to terminate</li>
        <li>Some languages have a compromise solution: types are present most of the time, but in rare situations the type
        discipline can be ignored</li>
    </ul></li>
</ul>

<hr/>

<h3 id="papers"> Past Papers </h3>

<hr/>
<!-- Utils -->
<button onclick="topFunction()" id="topBtn" title="Go to top">Top</button>
<script>
    // When the user scrolls down 20px from the top of the document, show the button
    window.onscroll = function() {scrollFunction()};

    function scrollFunction() {
        if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
            document.getElementById("topBtn").style.display = "block";
        } else {
            document.getElementById("topBtn").style.display = "none";
        }
    }

    // When the user clicks on the button, scroll to the top of the document
    function topFunction() {
        document.body.scrollTop = 0;
        document.documentElement.scrollTop = 0;
    }
</script>
<button onclick="window.location.href='index.html'" id="homeBtn" title="Back to Home"> Home </button>

</body>
</html>