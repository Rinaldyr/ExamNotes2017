<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title> Models of Computation </title>
    <style type="text/css">
        body {
            background-color: #fbffd8;
            font-family: "Georgia", serif;
        }

        ol > li {
            margin: 10px;
        }

        #topBtn {
            display: none;
            position: fixed;
            bottom: 80px;
            right: 20px;
            z-index: 99;
            border: none;
            outline: none;
            background-color: red;
            color: white;
            cursor: pointer;
            padding: 15px;
            border-radius: 10px;
        }

        #topBtn:hover {
            background-color: #555;
        }

        #homeBtn {
            display: block;
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 99;
            border: none;
            outline: none;
            background-color: red;
            color: white;
            cursor: pointer;
            padding: 15px;
            border-radius:10px;
        }

        #homeBtn:hover {
            background-color: #555;
        }
    </style>
</head>
<body>
<hr/>
<h1> LI Models of Computation </h1>
<hr/>
Table of Contents
<ol>
    <li> <a href="#fsa"> Language and Automata </a> <ul>
        <li> <a href="#fsa1"> Problems and Computers </a> </li>
        <li> <a href="#fsa2"> Regular Expression </a> </li>
        <li> <a href="#fsa3"> Finite State Automaton</a> </li>
        <li> <a href="#fsa4"> Bisimulation </a> </li>
    </ul> </li>
    <li> <a href="#dec"> Decidability </a> <ul>
        <li> <a href="#dec1"> Decision Problems </a> </li>
        <li> <a href="#dec2"> The Halting Theorem </a> </li>
        <li> <a href="#dec3"> Properties of Code </a> </li>
    </ul></li>
    <li> <a href="#tm"> Turing Machines </a> <ul>
        <li> <a href="#tm1"> Executing TMs </a> </li>
        <li> <a href="#tm2"> Designing TMs </a> </li>
        <li> <a href="#tm3"> Extensions of TMs </a> </li>
        <li> <a href="#tm4"> Church's Thesis </a> </li>
    </ul></li>
    <li> <a href="#comp"> Complexity </a> <ul>
        <li> <a href="#comp1"> Complexity of Algorithms </a> </li>
        <li> <a href="#comp2"> Complexity of Problems </a> </li>
        <li> <a href="#comp3"> O notation </a> </li>
        <li> <a href="#comp4"> NP Problems </a> </li>
        <li> <a href="#comp5"> NP-complete Problems </a> </li>
        <li> <a href="#comp6"> Satisfiability </a> </li>
    </ul></li>
    <li> <a href="#lambda"> Lambda Calculus </a> <ul>
        <li> <a href="#lambda1"> Lambda Application </a> </li>
        <li> <a href="#lambda2"> Evaluating Expressions </a> </li>
        <li> <a href="#lambda3"> Typed Lambda Calculus </a> </li>
        <li> <a href="#lambda4"> Typed vs Untyped </a> </li>
    </ul></li>
    <li> <a href="#papers"> Past Papers </a> </li>
</ol>

<hr/>

<h3 id="fsa"> Languages and Automata </h3>
<h4 id="fsa1"> Problems and Computers </h4>
<p> <em> This module is about problems and computers, except for the last part which is about &lambda;-calculus. </em> </p>

<p> Some questions that we can ask ourselves: </p>
<ul>
    <li> What problems can be solved on a computer? </li>
    <li> What problems can be solved on a computer with only finitely many states? </li>
    <li> What problems can be solved <em> fast </em> on a computer? </li>
    <li> What does "fast" mean anyway? </li>
    <li> What does "computer" mean anyway? </li>
    <li> etc.. </li>
</ul>

<h4> Language Membership Problems </h4>
Suppose that we have a set of characters, the alphabet &Sigma;. <br/>
A word (or string) is a finite sequence of characters. <br/> We write &Sigma;* for the set of all words. We can concatenate words. <br/>
The empty word is written as &epsilon;. <br/>
A language is a set of words, which means that it is a subset of &Sigma;*. <br/>

<p> Example language 1 <br/>
    Let's say the alphabet is {a,b,c}. The image below shows some example languages: <br/>
    <img src="images/models/fsa1.JPG"/> <br/>
    This can be applicable in real-life situations such as: <br/>
    <img src="images/models/fsa2.JPG"/> <br/>
    In all of these examples, somebody has provided a word and we want to know whether it is an acceptable word. Ideally, we want a computer program that will tell us. </p>

<h4 id="fsa2"> Regular Expressions </h4>
<p> Every regular expression gives rise to a language &ndash; a <em> regular language </em>. Some useful notations for describing languages: </p>
<ul>
    <li> We write <em> Empty </em> for the language consisting of no words, or the empty set. </li>
    <li> We write <em> a </em> for the language consisting of the single-character word <em> a </em> </li>
    <li> We write &epsilon; for the language consisting of just the empty word. </li>
    <li> Suppose <em> L </em> and <em> L' </em> are languages. <ul>
        <li> We write <em> LL' </em> for the set of words that are a concatenation of a word in <em> L </em> and a word in <em> L' </em> </li>
        <li> We write <em> L | L'</em> for the set of words that are either in <em> L </em> or <em> L' </em>. This is basically the union of <em> L </em> and <em> L' </em>. </li>
        <li> We write <em> L* </em> for the set of words that are a concatenation of some number of words in <em> L </em>. Note that "some number" might be 0, so the empty word is in <em> L* </em>. </li>
    </ul> </li>
</ul>
<p> All expressions built up this way makes a regular expression. A regular expression <em> E </em> can be either Empty, &epsilon;, <em> a, b c, </em> or anything in the alphabet, <em> EE' </em>, <em> E | E' </em>, or <em> E* </em>. </p>

<p> Just like arithmetic expressions, you can't make sense of regular expressions without knowing the precedence rules. <em> * </em> has the highest precedence, then juxtaposition (putting things next to each other, you juxtapose AB in algebra means A * B, or <strong> concatenation</strong>) then |.</p>

<p style="font-weight: bold"> Example exercises </p>
<ol>
    <li> Is the word <em> abb </em> in the language <em> a(b|c)* </em> ? &emsp; <span style="border: 1px solid darkgoldenrod;" onmouseenter="this.innerHTML='Yes, because a matches then b then b since (b|c)*'"> Hover for answer </span> </li>

    <li> Is the word <em> abc </em> in the language <em> a(b|c)* </em> ? &emsp; <span style="border: 1px solid darkgoldenrod;" onmouseenter="this.innerHTML='Yes, because a matches then b then c since (b|c)*'"> Hover for answer </span> </li>

    <li> Is the word <em> aabbab </em> in the language <em> (a(b|c)*)* </em> ? &emsp; <span style="border: 1px solid darkgoldenrod;" onmouseenter="this.innerHTML='Yes, because a abb ab'"> Hover for answer </span> </li>

    <li> Is the word <em> abbabca </em> in the language <em> (ab|ba)* </em> ? &emsp; <span style="border: 1px solid darkgoldenrod;" onmouseenter="this.innerHTML='No, because c is not in the language'"> Hover for answer </span> </li>

    <li> is the language <em> ((a|b)(b|c))* </em> the same as the language <em> (ab|ac|bb|bc)* </em> ? &emsp; <span style="border: 1px solid darkgoldenrod;" onmouseenter="this.innerHTML='Yes, because they are can form either ab or ac or bb or bc, then * the whole thing'"> Hover for answer </span> </li>

    <li> For each regexp <em> E </em>, could you write a program that takes a word <em> w </em> and says whether it's in the language represented by E? &emsp; <span style="border: 1px solid darkgoldenrod;" onmouseenter="this.innerHTML='Yes, a very efficient one'"> Hover for answer </span> </li>

    <li> Could you write a single program that takes a word <em> w </em> and a regexp <em> E </em> and says whether <em> w </em> is in the language represented by <em> E </em> ? &emsp; <span style="border: 1px solid darkgoldenrod;" onmouseenter="this.innerHTML='Yes'"> Hover for answer </span> </li>

    <li> Could you write a program that takes two regexps and says whether they represent the same language? &emsp; <span style="border: 1px solid darkgoldenrod;" onmouseenter="this.innerHTML='Yes, but it is not obvious'"> Hover for answer </span> </li>
</ol>

<p> Regular expression in theoretical computer science means an expression built up from the above operations and nothing more. The term has come to be used in Linux etc. to include various other operations. Regexps are also used in a somewhat different sense to find occurrences of words within a larger word. </p>

<p> <strong> Kleene's theorem </strong> says a language is regular (i.e. recognized by a regular expression) if and only if it is accepted by a finite state automaton. </p>

<p> Here are a few common abbreviations, it is optional to use these. <br/> <img src="images/models/fsa3.JPG"/> </p>


<h3 id="fsa3"> Finite State Automaton </h3>
<p> A finite state automaton over &Sigma; is </p>
<ul>
    <li> a finite set &Qopf; of states (<em> nodes </em>) </li>
    <li> a transition function &Qopf; &times; &Sigma; &rightarrow; &Qopf; (<em> paths, edges </em>) </li>
    <li> a set Acc &subseteq; &Qopf; of accepting states (<em> double nodes </em>) </li>
    <li> an initial state <em> q<sub>0</sub> </em> &epsi; &Qopf; (<em> diamond node </em>) </li>
</ul>
<p> Every finite state automaton has an associated language. To convert a partial FSA into a complete FSA, simply add an error state. </p>

<p> <span style="font-weight: bold;"> Removing &epsilon;-transitions </span> <br/> There's a <em> slow a-transition </em> from state q to state q' when, starting from state q we can follow some number of &epsilon;-transition, and end in state q'. A state q is <em> slowly accepting </em> when, starting from state q we can follow some number of &epsilon;-transitions and reach an accepting state. </p>

<p> But if we want to remove all &epsilon;-transitions, we keep the set of states, keep the initial state, replace the slow transitions by transitions, and replace slowly accepting states by accepting states. After removing all &epsilon;-transitions, we will obtain a Non-Deterministic Finite Automaton (NDFA). </p>

<p> <span style="font-weight: bold;"> Determinisation </span> <br/> Given a NDFA, we can form a Deterministic Finite Automaton (DFA) by first having the states a subset of &Qopf;, then from a state U &subseteq; &Qopf;, when we input a, take the set of all states that we can reach by an a-transition from a state in U. An accepting state is any that contains a state in Acc. The initial state is {<em>q<sub>0</sub></em>}. </p>

<p> <span style="font-weight: bold;"> Converting a regexp into a DFA </span> <br/> Convert first into NDFA by removing &epsilon;-transitions, and then determinise as mentioned above. </p>

<p> <span style="font-weight: bold;"> Converting DFA into a regexp </span> <br/> So say we have states {0,1,...,<em>n</em> &ndash; 1}. <br/> For any state <em>i</em> and <em>j</em> and any <em>k &le; n</em>, we want a regexp <em> E <span style="position: relative; top: 0.5em; left: -0.3em;"> <em> i&rightarrow;j</em></span> <span style="position:relative; top: -0.5em; left: -1.8em;"> &lt;k </span> </em> <br/> that accepts those words that take us from <em>i</em> and <em>j</em> with intermediate states all &lt; <em>k</em>. <br/>
    The image below shows the formula to convert DFA into a regexp. <br/> <br/> <img src="images/models/fsa4.JPG"/> </p>

<p> <em> Note: Every node in NDFA will always have equal number of transitions, and that number is all the possible transitions, and each of them are labelled with sets of states. </em> </p>

<p> <span style="font-weight: bold;"> Operations on Regular Languages </span> <br/> We can use Kleene's theorem to prove that some languages are regular. Firstly, the complement of a regular language L is regular. <br/> The proof is to get a DFA that recognises L, and by Kleene's theorem, the new complement automaton will have accepting states that are the set &Qopf;\Acc. This recognises the complement of L, so the latter is regular. <br/> The intersection of regular languages L and L' is regular (Corollary), because it's the complement of the union of the complements L and L' by Kleene's theorem. If L and L' are regular, then L \ L' is regular because L &cap; (&Sigma; \ L') by corollary. </p>

<p> <span style="font-weight: bold;"> Proving a language is not regular </span> <br/> We can prove this by finding an L-distinguishing suffix for words. Suppose we have a DFA that recognises the language L. And if we have words that have an L-distinguishing suffix, then each word must take us from the initial state to different states. <br/>
    If there is a countable sequence of distinctive words, then the minimum states of the DFA will be equal to the size of the set. <br/>
    However, if it is an infinite sequence of distinctive words, then there will be no DFA, and by Kleene's theorem the language is not regular. (<em>Myhill-Nerode Theorem</em>)<br/> </p>
<p> Also by the use of <strong> pumping lemma</strong>, which says that for any regular language L there exists a constant p such that any word w in L with length at least p can eb split into three substrings, w = xyz, where the middle portion of y must not be empty, such that the words xz, xyz, xyyz, xyyyz, ... constructed by repeating y zero or more times are still in L. The repetition process is called "pumping". Moreover, the pumping lemma guarantees that the length of xy will be at most p, imposing a limit on the way in which w may be split. Finite languages trivially satisfy the pumping lemma by having p equal to the maximum string length in L plus one. </p>

<h4 id="fsa4"> Bisimulation </h4>
<p> An <em> unpointed automaton </em> is one that has no initial state. <br/> A <strong> bisimulation </strong> between unpointed total deterministic automata (&Qopf;, &sigma;, Acc) and (&Qopf;', &sigma;', Acc') with the same alphabet L is a relation R &subseteq; &Qopf; &times; &Qopf;' such that if <em> qRq' </em> and a &epsi; L then &sigma;(q,a)R&sigma;'(q',a), and if <em> qRq' </em> then q &epsi; Acc iff q' &epsi; Acc'. <br/>
    Suppose that we have to unpointed automata for the same alphabet L. Then a state <em>q<sub>0</sub></em> &epsi; Q is bisimilar to a state <em>q'<sub>0</sub></em> if and only if they accept the same language. To prove this, show that for any word <em> w </em>, if <em>qRq'</em> then <em> q </em> accepts <em> w </em> if and only if <em> q' </em> accepts <em> w</em>. This is by induction on <em> w</em>. </p>

<p> The theorem is that two states accept the same language iff they are bisimilar. </p>

<h4 id="fsa5"> Minimisation </h4>
<p> To minimise an automaton means to throw away unreachable states and to identify bisimilar states. </p>
<ol>
    <li> Draw a table for all pairs of states (P,Q) </li>
    <li> Mark all pairs where P &in; Acc and Q &notin; Acc </li>
    <li> If there are any unmarked pairs (P,Q) such that transitions [&sigma;(P,x), &sigma;(Q,x)] is marked, then mark [P,Q] where 'x' is an input symbol. Repeat this until no more markings can be made. </li>
    <li> Combine all the unmarked pairs and make them a single state in the minimised DFA </li>
</ol>

<hr/>

<h3 id="dec"> Decidability </h3>

<hr/>

<h3 id="tm"> Turing Machines </h3>

<hr/>

<h3 id="comp"> Complexity </h3>

<hr/>

<h3 id="lambda"> Lambda Calculus </h3>

<hr/>

<h3 id="papers"> Past Papers </h3>

<hr/>
<!-- Utils -->
<button onclick="topFunction()" id="topBtn" title="Go to top">Top</button>
<script>
    // When the user scrolls down 20px from the top of the document, show the button
    window.onscroll = function() {scrollFunction()};

    function scrollFunction() {
        if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
            document.getElementById("topBtn").style.display = "block";
        } else {
            document.getElementById("topBtn").style.display = "none";
        }
    }

    // When the user clicks on the button, scroll to the top of the document
    function topFunction() {
        document.body.scrollTop = 0;
        document.documentElement.scrollTop = 0;
    }
</script>
<button onclick="window.location.href='index.html'" id="homeBtn" title="Back to Home"> Home </button>

</body>
</html>