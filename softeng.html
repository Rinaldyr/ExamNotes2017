<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
    <!--[if lt IE 9]>
    <script> document.createElement("keyword"); </script>
    <![endif]-->

    <style type="text/css">
        body {
            font-family: "Century Gothic", serif;
            margin: 50px;
        }

        h1 {
            color: #2e4566;
        }

        h2 {
            text-decoration: underline;
            color: #2f5496;
        }

        h3 {
            color: #5b9bd5;
        }

        h4 {
            font-weight: normal;
            color: #70c4f5;
        }

        hr {
            border-color: #59a7ea;
        }

        keyword {
            color: #c976c6;
            font-weight: bold;
        }

        table, th, td {
            border: 1px solid black;
            border-collapse: collapse;
        }

        th, td {
            padding: 8px;
        }

        #topBtn {
            display: none;
            position: fixed;
            bottom: 80px;
            right: 20px;
            z-index: 99;
            border: none;
            outline: none;
            background-color: #3460a9;
            color: white;
            cursor: pointer;
            padding: 15px;
            border-radius: 10px;
        }

        #topBtn:hover {
            background-color: #555;
            opacity: 0.5;
        }

        #homeBtn {
            display: block;
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 99;
            border: none;
            outline: none;
            background-color: #3460a9;
            color: white;
            cursor: pointer;
            padding: 15px;
            border-radius: 10px;
        }

        #homeBtn:hover {
            background-color: #555;
            opacity: 0.5;
        }
    </style>
    <meta charset="UTF-8">
    <title> Software Engineering </title>
    <link href="images/icon.png" rel="icon"/>
</head>
<body>
<hr/> <!----------------------------------------------------------------------------------->
<h1 align="center"> LI Software Engineering Extended 1 </h1>
<p align="center"> Template and style original: <keyword>Rhys Barrett</keyword>. </p>
<h3 align="center"> Click <a href="https://github.com/Rinaldyr/ExamNotes2017/blob/master/Softeng1.md">here</a> for Ahmed's Notes! </h3>
<hr/> <!----------------------------------------------------------------------------------->
Table of contents (<a href="#" onclick="var expanded=this.innerHTML==='expand'; var subtopics=document.getElementsByClassName('subtopic'); for (var i = 0; i < subtopics.length; i++) { subtopics[i].style.display=(expanded ? '' : 'none'); } this.innerHTML=(expanded ? 'collapse' : 'expand');">expand</a>)
<ol>
    <li><a href="#intro"> Introduction </a></li>
    <li><a href="#models"> Software Process Models </a><ul class="subtopic" style="display: none">
        <li><a href="#models1"> Waterfall Model </a></li>
        <li><a href="#models2"> Evolutionary Development </a></li>
        <li><a href="#models3"> Component-based Software Engineering </a></li>
        <li><a href="#models4"> Incremental Delivery </a></li>
        <li><a href="#models5"> Spiral Development </a></li>
        <li><a href="#models6"> Rational Unified Process </a></li>
    </ul></li>
    <li><a href="#reqeng"> Requirements Engineering </a><ul class="subtopic" style="display: none">
        <li><a href="#reqeng1"> Software Development Lifecycle </a></li>
    </ul></li>
    <li><a href="#system"> System </a><ul class="subtopic" style="display: none">
        <li><a href="#system1"> Critical System </a></li>
        <li><a href="#system2"> Dependability </a></li>
        <li><a href="#system3"> Faults and Failures </a></li>
    </ul></li>
    <li><a href="#agile"> Rapid and Extreme Programming </a><ul class="subtopic" style="display: none">
        <li><a href="#agile1"> Rapid Software Development </a></li>
        <li><a href="#agile2"> Agile Methods </a></li>
        <li><a href="#agile3"> Rapid Application Development </a></li>
    </ul></li>
    <li><a href="#inception"> Inception Phase </a><ul class="subtopic" style="display: none">
        <li><a href="#inception1"> Business Process Modelling </a></li>
        <li><a href="#inception2"> Activity Diagram </a></li>
    </ul></li>
    <li><a href="#reqdoc"> Requirements Documentation </a><ul class="subtopic" style="display: none">
        <li><a href="#reqdoc1"> Types of Requirements </a></li>
        <li><a href="#reqdoc2"> Functional and Non-Functional Requirements </a></li>
        <li><a href="#reqdoc3"> Sequence Diagrams </a></li>
        <li><a href="#reqdoc4"> About Requirements Documents </a></li>
    </ul></li>
    <li><a href="#reqcap"> Requirements Capture </a><ul class="subtopic" style="display: none">
        <li><a href="#reqcap1"> About Requirements Capture </a></li>
        <li><a href="#reqcap2"> Viewpoints </a></li>
        <li><a href="#reqcap3"> Fact-Finding Techniques </a></li>
        <li><a href="#reqcap4"> Requirements Checking </a></li>
        <li><a href="#reqcap5"> Requirements Validation </a></li>
    </ul></li>
    <li><a href="#reqana"> Requirements Analysis </a><ul class="subtopic" style="display: none">
        <li><a href="#reqana1"> Goal Oriented Requirements Engineering (GORE) </a></li>
        <li><a href="#reqana2"> KAOS </a></li>
        <li><a href="#reqana3"> MoSCoW </a></li>
    </ul></li>
    <li><a href="#usecase"> UML Use Case </a><ul class="subtopic" style="display: none">
        <li><a href="#usecase1"> Use Case Diagram </a></li>
        <li><a href="#usecase2"> Use Case Description </a></li>
    </ul></li>
    <li><a href="#sysdgn"> System Design </a><ul class="subtopic" style="display: none">
        <li><a href="#sysdgn1"> Major Activities </a></li>
        <li><a href="#sysdgn2"> Software Architecture </a></li>
    </ul></li>
    <li><a href="#pm"> Software Project Management Overview </a><ul class="subtopic" style="display: none">
        <li><a href="#pm1"> Software Project Management </a></li>
        <li><a href="#pm2"> Project Planning Process </a></li>
        <li><a href="#pm3"> Gantt Charts and Activity Networks </a></li>
        <li><a href="#pm4"> SMART Criteria </a></li>
    </ul></li>
    <li><a href="#risks"> Project Risk Management </a><ul class="subtopic" style="display: none">
        <li><a href="#risks1"> RM Process </a></li>
    </ul></li>
    <li><a href="#quality"> Software Quality Management </a><ul class="subtopic" style="display: none">
        <li><a href="#quality1"> Quality Management Activities </a></li>
        <li><a href="#quality2"> Standards </a></li>
        <li><a href="#quality3"> Quality Plans </a></li>
        <li><a href="#quality4"> Software Measurements and Metrics </a></li>
    </ul></li>
    <li><a href="#config"> Software Configuration Management </a><ul class="subtopic" style="display: none">
        <li><a href="#config1"> Configuration Management Planning </a></li>
        <li><a href="#config2"> Change Management </a></li>
        <li><a href="#config3"> Version Management </a></li>
        <li><a href="#config4"> Release Management </a></li>
        <li><a href="#config4"> System Building </a></li>
    </ul></li>
    <li><a href="#interface"> User Interface Design </a><ul class="subtopic" style="display: none">
        <li><a href="#interface1"> Design Principles </a></li>
        <li><a href="#interface2"> UI Design Process </a></li>
    </ul></li>
    <li><a href="#distribute"> Distributed Systems Architecture </a><ul class="subtopic" style="display: none">
        <li><a href="#distribute1"> Architecture Categorisation </a></li>
        <li><a href="#distribute2"> Implementation Diagrams </a></li>
    </ul></li>
    <li><a href="#semanticweb"> Semantic Web Introduction </a></li>
</ol>
<hr/> <!----------------------------------------------------------------------------------->

<h2 id="intro"> 1 &ndash; Introduction to Software Engineering </h2>
<p> What is software engineering? It is a branch of systems engineering concerned with the development of large and
    complex software intensive systems. It focuses on <strong> real world goals </strong> for, services provided by, and
    constrains on such systems. There is also the precise <strong> specification of systems structure and
        behaviour </strong>, and the implementations of these specifications. Furthermore, the activities required in
    order to develop <strong> an assurance </strong> that the specifications and the real world goals have been met.
    Also the <strong> evolution </strong> of these systems over time, and across systems families. It is also concerned
    with the <strong> processes, methods and tools </strong> for the development of software intensive systems in an
    <strong> economic and timely manner</strong>. </p>

<p><strong> Problems in system development </strong> may come from either the End-user's perspective, the Client's
    perspective, or the Developer's perspective. </p>
<p> Problems: <keyword>End-user</keyword> </p>
<ul>
    <li> System is not finished</li>
    <li> System has poor design, hard to use, poor interface, useless 'help'</li>
    <li> System is pretty but not useful</li>
</ul>
<p> Problems: <keyword>Client</keyword> </p>
<ul>
    <li> Project is overbudget</li>
    <li> Project is delivered late</li>
    <li> Project is no longer needed</li>
    <li> System is not trustworthy or safe to use</li>
</ul>
<p> Problems: <keyword>Developer</keyword> </p>
<ul>
    <li> Clients changed their minds</li>
    <li> There is not enough time to complete the project</li>
    <li> Development is disturbed by changing technology</li>
    <li> Developer does not have the necessary skills to fix or develop</li>
    <li> And sometimes, the system works fine but it's just the user with the problems</li>
</ul>

<p> Things go wrong because of two reasons: <keyword>Quality</keyword> and <keyword>Productivity</keyword> </p>
<ul>
    <li> <keyword>Quality</keyword> <ul>
        <li> The wrong problem is addressed so the system conflicts with business strategy</li>
        <li> The context is neglected</li>
        <li> The project has poor software engineering &ndash; incorrect analysis or design, or the team simply lack
            skills
        </li>
        <li> The project is carried out for the wrong reason</li>
    </ul> </li>

    <li> <keyword>Productivity</keyword> <ul>
        <li> The client needs change over time, so there is always a requirements drift</li>
        <li> External event changes the environment, e.g. legislation, change in technology</li>
        <li> Poor project management</li>
        <li> Implementation not feasible with over ambitious aims</li>
    </ul> </li>
</ul>

<p> Software Engineering is one of the most technically challenging and practically demanding subjects in computer science. It addresses problems which are faced by day-to-day practitioners. </p>

<hr/> <!----------------------------------------------------------------------------------->

<h2 id="models"> 2 &ndash; Software Process Models </h2>
<p> A structured set of activities required to develop a software system. It consists of <keyword> Specification, Design, Validation, Evolution</keyword>. A <keyword> software process model</keyword> is an abstract representation of a process. It presents a description of a process from some particular perspective. </p>
<p> Process models: </p>
<ul>
    <li> Waterfall Model: Separate and distinct phases of specification and development. </li>
    <li> Evolutionary Development: Specification, development and validation are interleaved. </li>
    <li> Component-based Soft Eng: The system is assembled from existing components. </li>
</ul>

<h3 id="models1"> 2.1 &dash; Waterfall Model </h3>
<img src="images/softeng/models1.JPG"/>
<ol>
    <li> <keyword> Requirements analysis and definition </keyword> <ul>
        <li> The process of establishing what services are required and the constraints on the system's operation and development. </li>
        <li> Requirements Engineering Process, which includes feasibility study, requirements elicitation and analysis, requirements specification, requirements validation. <br/><img src="images/softeng/models2.JPG"/> </li>
    </ul></li>

    <li> <keyword> System and software design </keyword> a structure that realises the specification <ul>
        <li> Architectural design </li>
        <li> Abstract specification </li>
        <li> Interface design </li>
        <li> Component design </li>
        <li> Data structure design </li>
        <li> Algorithm design </li>
        <li> And so on... <br/> <img src="images/softeng/models3.JPG"/> </li>
    </ul></li>

    <li> <keyword> Implementation and unit testing </keyword> <ul>
        <li> Have to already produce executable code. </li>
        <li> Unit testing individual components for functions, classes or programs independently. </li>
        <li> Components may be functions or objects or coherent groupings of these entities. </li>
    </ul></li>

    <li> <keyword> Integration and system testing </keyword> <ul>
        <li> System testing: Testing the system as a whole. Testing of emergent properties is particularly important. </li>
        <li> Acceptance testing: Testing with customer data to check that the system meets the customer's needs. </li>
    </ul></li>

    <li> <keyword> Operation and maintenance </keyword> to keep the system going. </li>
</ol>

<p><strong> Problems of Waterfall Model </strong></p>
<ul>
    <li> One phase has to be complete before moving on to the next phase. </li>
    <li> Inflexible partitioning of the project into distinct stages makes it difficult to respond to changing customer requirements. <br/> Therefore this model is only appropriate when the requirements are well understood and the changing will be fairly limited during the design process. </li>
    <li> But only a few business systems have stable requirements. </li>
</ul>

<h3 id="models2"> 2.2 &ndash; Evolutionary Development </h3>
<p> Specification, development and validation is all concurrently ongoing. <br/>
    <img src="images/softeng/models4.JPG"/> <br/> </p>
<ul>
    <li> Exploratory development: To work with customers and to evolve a final system from an initial outline specification. Start with well understood requirements and add new features as proposed by the customer. </li>
    <li> Throw-away prototyping: To understand the system requirements. So should start with poorly understood requirements to clarify what is really needed. </li>
</ul>

<p><strong> Problems with Evolutionary Development </strong></p>
<ul>
    <li> Lack of process visibility </li>
    <li> Systems are often poorly structured </li>
    <li> Special skills such as in languages for rapid prototyping may be required </li>
    <li> May not be applicable for small or medium-sized interactive systems </li>
    <li> May not be applicable for parts of large systems like the user interface </li>
    <li> May not be applicable for short-lifetime systems </li>
</ul>

<h3 id="models3"> 2.3 &ndash; Component-based Software Engineering </h3>
<p> This is based on systematic reuse where systems are integrated from existing components or <keyword> Commercial-off-the-shelf (COTS) </keyword> systems. </p>
<p> Process stages include component analysis, requirement modification, system design with reuse, and development and integration. <br/> Reuse-oriented development <br/> <img src="images/softeng/models5.JPG"/> </p>

<h3> Process Iteration </h3>
<p> System requirements <em> ALWAYS </em> evolve in the course of a project, so process iteration where earlier stages are reworked is always part of the process for large systems. Iterations can be applied to any of the generic process models. </p>

<h3 id="models4"> 2.4 &ndash; Incremental Delivery </h3>
<p> Rather than deliver the system as a single delivery, the development and delivery is broken down into increments with each increment delivering part of the required functionality. </p>
<p> User requirements are prioritised and the highest priority requirements are included in early increments. Once the development of an increment is started, the requirements are frozen through for later increments to evolve. </p>
<img src="images/softeng/models6.JPG"/>
<p> The advantage of this development style </p>
<ul>
    <li> Early increments act as a prototype to help elicit requirements for later increments. </li>
    <li> Lower risk of overall project failure. </li>
    <li> The highest priority system services tend to receive the most testing. </li>
    <li> Customer value can be delivered with each increment so system functionality is available earlier. </li>
</ul>

<h3 id="models5"> 2.5 &ndash; Spiral Development </h3>
<p> The process is represented as a spiral rather than as a sequence of activities with backtracking. Each loop in the spiral represents a phase in the process. There are no fixed phases such as specification or design &ndash; loops in the spiral are chosen depending on what is required. Risks are explicitly assessed and resolved throughout the process. </p>
<img src="images/softeng/models7.JPG"/>


<h3 id="models6"> 2.6 &ndash; Rational Unified Process (RUP) </h3>
<img src="images/softeng/models8.JPG"/>
<p> There are four RUP phases </p>
<ol>
    <li> <keyword>Inception</keyword>: Establish the business case for the system. <ul>
        <li> Formulating the scope of the project. </li>
        <li> Planning and preparing the business case. </li>
        <li> Synthesizing a candidate architecture. </li>
        <li> Preparing the environment for the project. </li>
    </ul></li>
    <li> <keyword>Elaboration</keyword>: Develop an understanding of the problem domain and the system architecture. <ul>
        <li> Defining, validating the baseline architecture. </li>
        <li> Refining the vision. </li>
        <li> Creating detail of iteration plans for the construction phase. </li>
        <li> Refining the development case and putting in place the development environment. </li>
        <li> Refining the architecture and selecting components. </li>
    </ul></li>
    <li> <keyword>Construction</keyword>: System design, programming and testing. <ul>
        <li> Resource management, control and process optimisation. </li>
        <li> Complete component development and testing against the defined evaluation criteria. </li>
        <li> Assessment of product releases against acceptance criteria for the vision. </li>
    </ul></li>
    <li> <keyword>Transition</keyword>: Deploy the system in its operating environment. <ul>
        <li> Executing deployment plans. </li>
        <li> Finalising end-user support material. </li>
        <li> Testing the deliverable product at the development site. </li>
        <li> Creating a product release and getting user feedback. </li>
        <li> Fine-tuning the product based on feedback. </li>
        <li> Making the product available to end-users. </li>
    </ul></li>
</ol>

<hr/> <!----------------------------------------------------------------------------------->

<h2 id="reqeng"> 3 &ndash; Requirements Engineering (RE) </h2>
<p> Requirements form the basis for Project Planning, Risk Management, Acceptance Testing and Change Control. </p>
<p> Most project's critical issues are in the requirements area. Major gaps in Requirements tend to be critical to a project success. Producing a good set of requirements is likely the most difficult job in software system development. </p>

<h4> Recurring problems </h4>
<ul>
    <li> Lack of functional requirements by either no requirements have been written, usage scenario not understood and documented, functionality of the system incomplete, customer not known and not contacted, or no acceptance criteria for the system. </li>
    <li> Lack of performance and capacity requirements: Number and/or types of users undocumented, transaction and data volumes unknown. </li>
    <li> Lack of operations, administration and management requirements. </li>
</ul>

<p> Good requirements describe <em> what </em> the system is supposed to do, <strong> not </strong> <em> how </em> the system is supposed to do it. Remember the 5W's and one H. </p>

<p> Requirements are <strong> not </strong> a description of how the system provides the needed functionality. Requirements should <strong>not</strong> specify technology or implementation except where those items are customer constraints. Requirements should not contain assumptions, should not be indecisive with words like "would", "could", "flexible" in the document. The item <strong> will </strong> or <strong> will not </strong> be in the system. Requirement should not be inconsistent or conflicting too. </p>

<p> Requirements are description of <strong> what </strong> the entire system is supposed to do: </p>
<ul>
    <li> Reflective of customer need </li>
    <li> Constraints imposed by the customer </li>
    <li> Constraints imposed by business and marketing needs </li>
    <li> Unambiguous (clear and concise) </li>
    <li> Complete </li>
    <li> Prioritised </li>
    <li> Traceable, meaning able to be followed </li>
    <li> Implementable within project constraints like schedule and budget </li>
    <li> Formally accepted by the customer, systems engineering and development, system test, and under change control </li>
</ul>
<p> Requirements are sometimes referenced for contacts, and also sometimes considered to be contract between systems engineering and development. </p>

<p> Customer and end-user are not always the same person. The end-user is the person who interacts with the system to get the job done, while the customer typically pays for the system. They may have similar or conflicting objectives. Sometimes delighting your end-user delights the customer, but remember that the customer pays for the job. So it is very important to get the customer involved in the initial phase of RE, if at all possible. </p>

<h3 id="reqeng1"> 3.1 &ndash; Software Development Lifecycle (SDLC) </h3>
<p> We have the <keyword> V Model</keyword>: If problems are found during Verification or Validation phase, the LHS of the V is re-executed to fix the problem. </p>
<img src="images/softeng/reqeng1.JPG"/>
<p> Prototyping allows all or part of the system to be constructed quickly in the hopes of clarifying and understanding issues. Iterate requirements and design to ensure common understanding. </p>

<h4> Role of requirements engineering </h4>
<p> Requirements influence the whole development from the start to end. Testing is with respect to the requirements. A system is accepted against Stakeholder's requirements during Acceptance Test Phase as shown in the image below. </p>
<img src="images/softeng/reqeng2.JPG"/>

<p> RE provides communication amongst projects. <br/> <keyword>Requirements traceability</keyword> refers to the ability to understand how high-level requirements (goals, objectives etc) are transformed into low-level requirements (mapping between layers of information: one-to-many usually). It is the ability to assess impact changes introduced at various phases of development lifecycle, and the ability to track progress. <br/> <em> Stakeholders req. met by system req &rightarrow; partitioned into subsystem req &rightarrow; implemented as components </em></p>

<p> <keyword>Traceability</keyword> is the use of requirements management tools to link requirements statements in on layer with statement in another. </p>

<p> Main requirements activities include </p>
<ul>
    <li> Requirements inception </li>
    <li> Requirements analysis </li>
    <li> Requirements specification </li>
    <li> Requirements verification and validation </li>
    <li> Requirements management </li>
    <li> Requirements documents </li>
</ul>

<hr/> <!----------------------------------------------------------------------------------->

<h2 id="system"> 4 &ndash; Systems </h2>
<p> A <keyword>system</keyword> is an organised or complex whole: an assemblage or combination of things or parts forming a complex or unitary whole. It is also a set of interrelated elements. </p>

<p> If the elements of a system are of a reasonable degree of complexity, which made them systems, then we call them <keyword>sub-systems</keyword>. </p>

<p> The <keyword>environment</keyword> of a system is the set of elements which are NOT part of the system, but a change in any of which can produce a change in the state of the system. </p>

<h3 id="system1"> 4.1 &ndash; Critical Systems </h3>
<p> <keyword>Critical system</keyword> is a system where failure can lead to high economic loss, physical damage, or threats to life. There are three critical systems: </p>
<ul>
    <li><keyword>Safety-critical</keyword><ul>
        <li> Failure results in loss of life, injury or damage to the environment. </li>
        <li> E.g. Chemical plant protection system </li>
    </ul></li>
    <li><keyword>Mission-critical</keyword><ul>
        <li> Failure results in failure of some goal-directed activity. </li>
        <li> E.g. Spacecraft navigation system </li>
    </ul></li>
    <li><keyword>Business-critical</keyword><ul>
        <li> Failure results in high economic loss. </li>
        <li> E.g. Customer accounting system in a bank </li>
    </ul></li>
</ul>
<p> It is usually the case that the most important system property is the <keyword>dependability</keyword> of the system. The dependability of a system reflects the user's degree of trust in that system. It reflects the extent of the user's confidence that it will operate as users expect and that it will not fail in normal use. </p>

<p> Systems that are not dependable (<keyword>unreliable, unsafe, insecure</keyword>) may be rejected by their users. The cost of critical system failure may be very high such that development method may be used for other types of system. </p>

<p><keyword>Socio-technical</keyword> in an organisational development is an approach to complex organisational work design that recognises the interaction between people and technology in workplaces. </p>
<ul>
    <li><keyword>Hardware failure</keyword><ul>
        <li> Design and manufacturing errors. </li>
        <li> Components have reached the end of their natural life. </li>
    </ul></li>
    <li><keyword>Software failure</keyword><ul>
        <li> Errors in its specification, design or implementation. </li>
    </ul></li>
    <li><keyword>Operational failure</keyword><ul>
        <li> Human operators make mistakes. </li>
    </ul></li>
</ul>

<h3 id="system2"> 4.2 &ndash; Dependability </h3>
<p> <keyword>Dependability</keyword> of a system equates to its trustworthiness. The principal dimensions of dependability are: </p>
<ul>
    <li><keyword>Availability</keyword><ul>
        <li> Probability that the system will be available to deliver services when requested. </li>
    </ul></li>
    <li><keyword>Reliability</keyword><ul>
        <li> Probability that system services will be delivered as specified. </li>
    </ul></li>
    <li><keyword>Safety</keyword><ul>
        <li> The ability of the system to operate without catastrophic failure. </li>
    </ul></li>
    <li><keyword>Security</keyword><ul>
        <li> The ability of the system to protect itself against accidental or deliberate intrusion. </li>
    </ul></li>
    <li>Repairability<ul>
        <li> Reflects the extent to which the system can be repaired in the event of a failure. </li>
    </ul></li>
    <li>Maintainability<ul>
        <li> Reflects the extent to which the system can be adapted to new requirements. </li>
    </ul></li>
    <li>Survivability<ul>
        <li> Reflects the extent to which the system can deliver services whilst under hostile attack. </li>
    </ul></li>
    <li>Error tolerance<ul>
        <li> Reflects the extent to which the user-input errors can be avoided and tolerated. </li>
    </ul></li>
</ul>

<p>Untrustworthy systems may cause loss of valuable information. It may be rejected by their users and failures cost very high. </p>

<p> There will be <strong>trade-offs</strong> between performance and dependability. </p>
<p> The costs tend to increase exponentially as increasing levels of dependability are required. This is because of: </p>
<ul>
    <li> Use of more expensive <strong>development techniques</strong> </li>
    <li> Increased <strong>testing and system validation</strong> </li>
</ul>
<img src="images/softeng/system1.JPG"/>

<p><keyword>Safety</keyword> is the system's ability to operate <strong>without danger of causing human injury or death</strong> and <strong>without damage to the system's environment</strong>.</p>

<p><keyword>Security</keyword> of a system is the system's ability to <strong>protect</strong> itself from <strong>accidental or deliberate external attack</strong>. It is an essential pre-requisite for availability, reliability and safety. </p>
<p> Damages that can be done from insecure systems: </p>
<ul>
    <li> Denial of service (DOS) </li>
    <li> Corruption of programs or data </li>
    <li> Disclosure of confidential information </li>
</ul>

<h3 id="system3"> 4.3 &ndash; Faults and Failures </h3>
<p> There are some terminologies related to reliability: </p>
<ul>
    <li><keyword>System Failure</keyword><ul>
        <li> An event that occurs at some point in time when the system does not deliver a service as expected by its users. </li>
    </ul></li>
    <li><keyword>System Error</keyword><ul>
        <li> An errorneous system state that can lead to system behavior that is unexpected by system users. </li>
    </ul></li>
    <li><keyword>System Fault</keyword><ul>
        <li> A characteristic of a software system that can lead to a system error. E.g. failure to initialise a variable leading to null pointers. </li>
    </ul></li>
    <li><keyword>Human Error</keyword><ul>
        <li> Human behaviour that results in the introduction of faults into a system. </li>
    </ul></li>
</ul>
<p> <keyword>Failures</keyword> are usually a result of system errors that are derived from the faults in the system. Faults do not necessarily result in system errors. Errors do not necessarily lead to system failures. </p>

<p><keyword>Fault avoidance</keyword> development techniques are used to minimise the possibility of mistakes or trap mistakes before they result in faults.</p>
<p><keyword>Fault detection and removal</keyword> verification and validation techniques are used to detect errors before the system goes into service. </p>
<p><keyword>Fault tolerance</keyword> runtime techniques are used to ensure that system faults do not result in system errors which do not lead to system failures. </p>

<hr/> <!----------------------------------------------------------------------------------->

<h2 id="agile"> 5 &ndash; Rapid and Extreme Programming </h2>
<h3 id="agile1"> 5.1 &ndash; Rapid Software Development (RSD) </h3>
<p><keyword>RSD</keyword> is due to the fact that business environments always change, so the business have to respond to new opportunities and competition. This is normally used for small and medium sized systems. </p>
<p> Characteristics </p>
<ul>
    <li>Processes of <strong>specification</strong>, <strong>design</strong> and <strong>implementation</strong> are <keyword>concurrent</keyword>.</li>
    <li>System is developed in a series of <keyword>increments</keyword>.</li>
    <li>End-users evaluate each increment and make proposals for later increments.</li>
    <li>Things may easily go wrong so <strong>best suited</strong> for <keyword>experienced</keyword> and <keyword>skillful</keyword> development teams. </li>
</ul>
<p> Waterfall model is <keyword>impractical</keyword> here.</p>
<h4> Iterative development process </h4>
<img src="images/softeng/agile1.JPG"/>

<h3 id="agile2"> 5.2 &ndash; Agile Methods </h3>
<ul>
    <li> Focus on the code rather than design </li>
    <li> Iterative approach </li>
    <li> Intended to deliver working software quickly and evolve quickly </li>
</ul>
<p> Agile methods are <strong>best suited</strong> to small or medium sized business systems. </p>
<p><strong>Principles of Agile Methods</strong></p>
<ul>
    <li> <keyword>Customer involvement</keyword> <ul>
        <li> Customers are to provide and prioritise new requirements and evaluate iterations. </li>
    </ul> </li>
    <li> <keyword>Incremental delivery</keyword> <ul>
        <li> Software is developed in increments. </li>
    </ul> </li>
    <li> <keyword>People not Process</keyword> <ul>
        <li> Team members should be allowed to develop their own ways of working. </li>
    </ul> </li>
    <li> <keyword>Embrace Change</keyword> <ul>
        <li> Design the system to accommodate constant changes. </li>
    </ul> </li>
    <li> <keyword>Maintain Simplicity</keyword> <ul>
        <li> Actively work to eliminate complexity from the system. </li>
    </ul> </li>
</ul>

<h4> Problems with Agile Method</h4>
<ul>
    <li> Can be difficult to keep the <keyword>interest</keyword> of involved customers. </li>
    <li> Team members <keyword>not suited</keyword> for the method. </li>
    <li> <keyword>Prioritising changes</keyword> can be difficult where there are multiple stakeholders. </li>
    <li> <keyword>Maintaining simplicity</keyword> requires extra work. </li>
    <li> <keyword>Contracts</keyword> </li>
</ul>

<h4> Extreme Programming (XP) </h4>
<p> This is an agile method that takes an 'extreme' approach to iterative development. </p>
<ul>
    <li> New versions may be built <keyword>several times per day</keyword>. </li>
    <li> Increments are delivered to customers <keyword>every 2 weeks</keyword>. </li>
    <li> Build is only accepted if <keyword>tests run successfully</keyword>. </li>
</ul>

<p><strong>Five Values of XP</strong></p>
<ul>
    <li><keyword>Communication</keyword><ul>
        <li> Nothing can be done well without communicating. </li>
    </ul></li>
    <li><keyword>Simplicity</keyword><ul>
        <li> Do the simplest thing that could possibly work. </li>
    </ul></li>
    <li><keyword>Feedback</keyword><ul>
        <li> Put valuable requirements into production as early as possible. </li>
    </ul></li>
    <li><keyword>Courage</keyword><ul>
        <li> Do the right thing! Throw away code that is no longer needed. </li>
    </ul></li>
    <li><keyword>Respect</keyword><ul>
        <li> Team members must respect other's work. </li>
    </ul></li>
</ul>

<h4> The XP Release Cycle </h4>
<img src="images/softeng/agile2.JPG"/>

<h4> XP Practices </h4>
<ul>
    <li><keyword>Incremental Planning</keyword><ul>
        <li> Requirements are recorded on <strong>story cards</strong> that focuses on <strong>user needs</strong>.</li>
        <li> Stories should be prioritised and chosen <strong>by the customer</strong>. </li>
        <li> Break down each story into tasks. <ul>
            <li> Each task has estimates of <em>schedule</em> and <em>cost</em>. </li>
        </ul></li>
    </ul></li>
    <li><keyword>Small Releases</keyword><ul>
        <li> Focus on releasing minimal functionality. </li>
        <li> Each increment adds more functionality. </li>
    </ul></li>
    <li><keyword>Simple Design</keyword><ul>
        <li> Design just enough to meet requirements. </li>
        <li> Even though it might lead to <strong>poor design</strong> and <strong>multiple refactorings</strong>. </li>
    </ul></li>
    <li><keyword>Test-first Development</keyword><ul>
        <li> Automated test framework is used to write tests for a new piece of functionality <strong>before</strong> the             functionality itself is implemented. <ul>
            <li> This is to <strong>clarify</strong> the requirements. </li>
            <li> Tests are written as <strong>programs</strong> rather than data. </li>
            <li> Tests are run when new functionality is added to ensure the update doesn't introduce errors. </li>
        </ul></li>
    </ul></li>
    <li><keyword>Refactoring</keyword><ul>
        <li> Refactor continuously as soon as an improvement is found. </li>
        <li> This is to keep code <strong>simple</strong> and <strong>maintainable</strong>. </li>
    </ul></li>
    <li><keyword>Pair Programming</keyword><ul>
        <li> Developers work in <strong>pairs</strong>. <ul>
            <li> Develop common ownership and spreads knowledge. </li>
            <li> Serves as an informal review process. </li>
            <li> Encourages refactoring. </li>
        </ul></li>
    </ul></li>
    <li><keyword>Collective Ownership</keyword><ul>
        <li> Everybody works on everything. No <strong>islands of expertise</strong>. </li>
    </ul></li>
    <li><keyword>Continuous Integration</keyword><ul>
        <li> Work is integrated to the system as soon as it is finished. </li>
        <li> All of the unit tests in the system must pass. </li>
    </ul></li>
    <li><keyword>Sustainable Pace</keyword><ul>
        <li> Large amounts of <strong>overtime</strong> are not considered acceptable. </li>
        <li> This reduces the <strong>net productivity</strong> of code. </li>
    </ul></li>
    <li><keyword>On-site customer</keyword><ul>
        <li>End-users and customers are <strong>members</strong> of the development team. </li>
    </ul></li>
</ul>

<h4> Critiques of XP </h4>
<ul>
    <li><strong>Code-centered</strong> rather than design-centered, bad for large systems. </li>
    <li>Not producing <strong>readable code</strong>.</li>
    <li>Lack of <strong>structured</strong> review process.</li>
    <li><strong>Quality through testing</strong>.</li>
    <li>Limited to a <strong>narrow</strong> segment of software work.</li>
    <li>Limited <strong>management support</strong>.</li>
    <li>Lack of <strong>transition support</strong>.</li>
</ul>

<h4> User Stories and Use Cases </h4>
<table>
    <tr>
        <th> User Story </th>
        <th> Use Case </th>
    </tr>
    <tr>
        <td> Small scale and easy-to-use presentation of information. </td>
        <td> Describes process and steps in detail. </td>
    </tr>
    <tr>
        <td> Formulated in everyday language of the user, no technical words. </td>
        <td> Can use technical words. </td>
    </tr>
    <tr>
        <td> Can be accompanied by Acceptance Testing procedures. </td>
        <td> Can be delivered in a stand-alone document. </td>
    </tr>
    <tr>
        <td> For customers </td>
        <td> For developers </td>
    </tr>
</table>

<h3 id="agile3"> 5.3 &ndash; Rapid Application Development (RAD) </h3>
<p> This development includes <keyword>Visual Development</keyword> and <keyword>COTS</keyword>.</p>
<ul>
    <li> Designed to develop <keyword>data-intensive</keyword> business applications. </li>
    <li> Rely on programming and presenting information from a <keyword>database</keyword>. </li>
    <li> Using <keyword>special tools</keyword> and <keyword>programming languages</keyword>. </li>
</ul>
<p> RAD environments include support for <keyword>interface generation</keyword> interactively: form <strong>definition</strong> using drag and drop techniques; form <strong>linking</strong> and form <strong>verification</strong>. </p>

<h4> Visual Programming </h4>
<p> Scripting languages such as Visual Basic. Prototype is created from an interface. </p>
<p> An example would be like below </p>
<img src="images/softeng/agile3.JPG"/>

<h4>Problems with Visual Development</h4>
<ul>
    <li> Difficult to coordinate <keyword>team-based</keyword> development. </li>
    <li> No explicit system architecture. </li>
    <li> Can have maintainability problems. </li>
    <li> Maintenance has to be done through original environment. </li>
    <li> Hard to <keyword>integrate</keyword> with other systems. </li>
</ul>

<h4> COTS Reuse </h4>
<p> As mentioned before in <a href="#models3">here</a>, COTS refers to <keyword>already available</keyword> applications. <keyword>Configure</keyword> and <keyword>link</keyword> existing off the shelf systems for an effective approach to rapid development. </p>

<p> Some application prototypes can be created by developing a <keyword>compound document</keyword>. This document has <keyword>active elements</keyword> like a spreadsheet that <strong>allows user computations</strong>. Each active elements has an <keyword>associated application</keyword> which is invoked when that element is selected. The document itself is the <keyword>integrator</keyword> for different applications. </p>

<hr/> <!----------------------------------------------------------------------------------->

<h2 id="inception"> 6 &ndash; Inception Phase </h2>
<p> The <keyword>Inception phase</keyword> focuses on the <keyword>business process modeling</keyword>, <keyword>requirements capture</keyword>, and the <keyword>start of analysis</keyword>. </p>

<p> Analysis has three parts: </p>
<ul>
    <li> Business Modelling </li>
    <li> Requirements Analysis </li>
    <li> System Analysis </li>
</ul>

<h3 id="inception1"> 6.1 &ndash; Business Process Modelling </h3>
<ol>
    <li> Build a <keyword>business process map</keyword> </li>
    <li> Develop <keyword>business scenarios</keyword> </li>
    <li> Derive <keyword>business workflows</keyword> </li>
    <li> Produce <keyword>business object models</keyword> </li>
</ol>
<h4> Business Process Map </h4>
<img src="images/softeng/inception1.JPG"/>

<h4> Business Scenario Analysis </h4>
<p> Forms the basis of analysis process: </p>
<ul>
    <li> <keyword>Business</keyword> analysis </li>
    <li> <keyword>Use case</keyword> analysis </li>
</ul>
<p> There are four parts to analysis is to describe and identify: </p>
<ol>
    <li> <keyword>Scenarios</keyword> &ndash; described by primary and alternative paths </li>
    <li> <keyword>Primary Paths</keyword> </li>
    <li> <keyword>Alternative Paths</keyword> </li>
    <li> <keyword>Exceptions</keyword> &ndash; when alternative paths fails </li>
</ol>

<p> The <keyword>80/20 principle</keyword> states that 80% of <strong>effort</strong> goes into 20% of <strong>activity</strong>. </p>

<h3 id="inception2"> 6.2 &ndash; Activity Diagrams </h3>
<p> A branch of UML diagrams, made by merging scenario analysis' <keyword>primary</keyword> and <keyword>alternative paths</keyword>. Used to <keyword>model business processes</keyword>. </p>
<img src="images/softeng/inception2.jpg"/>
<p> Apart from these we also have <keyword>swimlanes</keyword> which are useful to separate actors. </p>
<img src="images/softeng/inception5.JPG"/>
<p> Some examples: </p>
<div>
<img src="images/softeng/inception3.JPG"/>
<img src="images/softeng/inception4.JPG"/>
</div>

<h4> Stakeholder Involvement </h4>
<p> Building business processes requires many discussions with clients and stakeholders. </p>
<p> Record process in a <keyword>Process Catalogue</keyword>.</p>
<ul>
    <li> <keyword>Goals</keyword> of the process </li>
    <li> Necessary <keyword>preconditions</keyword> before the process can run </li>
    <li> <keyword>Criticality</keyword> of the process </li>
    <li> <keyword>Business actors</keyword> involved in the process </li>
</ul>

<hr/> <!----------------------------------------------------------------------------------->

<h2 id="reqdoc"> 7 &ndash; Requirements Documentation </h2>
<p> A <keyword>requirement</keyword> may be the basis for a bid for a contract, or it may be the basis for the contract itself, or both. </p>

<h3 id="reqdoc1"> 7.1 &ndash; Types of Requirements </h3>
<ul>
    <li> <keyword>User</keyword> <ul>
        <li> Statements in <keyword>natural language</keyword> and diagrams of the services the system provides and its constraints. </li>
        <li> Should describe <keyword>functional</keyword> and <keyword>non-functional</keyword> requirements. </li>
        <li> Written for <keyword>clients</keyword> without technical knowledge. </li>
    </ul></li>
    
    <li> <keyword>System</keyword> <ul>
        <li> Descriptions of the system's functions, services and operational <keyword>constraints</keyword>. </li>
        <li> Defines what should be <keyword>implemented</keyword>. </li>
        <li> Part of the contract. </li>
    </ul></li>
</ul>

<h3 id="reqdoc2"> 7.2 &ndash; Functional and Non-Functional Requirements </h3>
<p> Brief definition of these two: Functional requirements describe <strong>what</strong> the system <keyword>should do</keyword> while non-functional requirements describe <strong>how</strong> the system <keyword>works</keyword> </p>
<img src="images/softeng/reqdoc1.jpg"/>
<p> Requirements have to be written properly without any <keyword>ambiguity</keyword> or developers may interpret it differently than what is asked for. </p>

<p> Requirements have to be both complete and consistent: </p>
<ul>
    <li> Complete <ul>
        <li> They should include <keyword>descriptions</keyword> of all facilities required. </li>
    </ul></li>

    <li> Consistent <ul>
        <li> There should be <keyword>no conflicts or contradictions</keyword> in the descriptions of the system facilities. </li>
    </ul></li>
</ul>

<h4> Types of Non-functional Requirements </h4>
<ul>
    <li> <keyword>Product</keyword> requirements <ul>
        <li> Specify the way the delivered product must behave. </li>
        <li> Performance, Reliability, Availability, etc. </li>
    </ul> </li>

    <li> <keyword>Organisational</keyword> requirements <ul>
        <li> Consequence of organisational policies and procedures </li>
        <li> Process standards used, implementation requirements, etc. </li>
    </ul> </li>

    <li> <keyword>External</keyword> requirements <ul>
        <li> Factors which are external to the system and its development process </li>
        <li> Legislative requirements, etc. </li>
    </ul> </li>
</ul>

<p> A requirement is <keyword>verifiable</keyword> if it is possible to create and run a <keyword>test</keyword> of the final system that clearly demonstrates the requirement has been met. </p>

<p> <keyword>Domain</keyword> requirements are derived from the application domain and describe <keyword>system characteristics</keyword> and features that reflect the domain. </p>

<h4> Guidelines for Writing Requirements </h4>
<p> Create a <keyword>standard format</keyword> and use it for all requirements. Use language in a constant way. Use <keyword>shall</keyword> for mandatory requirements, <keyword>should</keyword> for desirable requirements. Avoid computing <keyword>jargon</keyword>. </p>

<h4> Problems with Natural Language </h4>
<ul>
    <li> <keyword>Ambiguous</keyword> &ndash; Different people may interpret it differently. </li>
    <li> <keyword>Too flexible</keyword> &ndash; Many ways to describe the same thing. </li>
    <li> <keyword>Lack of modularisation</keyword> &ndash; NL Structures are inadequate to structure system requirements. </li>
</ul>

<p> <strong>Alternatives to NL specification</strong> </p>
<table>
    <tr>
        <th> Notation </th>
        <th> Description </th>
    </tr>
    <tr>
        <td> Structured natural language </td>
        <td> Depends on defining standard forms to express the specification. </td>
    </tr>
    <tr>
        <td> Design description languages </td>
        <td> Uses a language like a programming language with more abstract features and models to specify the requirements . </td>
    </tr>
    <tr>
        <td> Graphical notations </td>
        <td> Graphics supplemented with text annotations. This includes use-case descriptions and sequence diagrams. </td>
    </tr>
    <tr>
        <td> Mathematical specifications </td>
        <td> Languages based on math concepts like finite state machines. </td>
    </tr>
</table>

<h3 id="reqdoc3"> 7.3 &ndash; Sequence Diagrams </h3>
<p> Shows the <keyword>sequence of events</keyword> that take place during some <keyword>user interaction</keyword> with a system. </p>
<div>
<img src="images/softeng/reqdoc2.JPG"/>
<img src="images/softeng/reqdoc3.JPG"/>
</div>
<ul>
    <li> <keyword>Synchronous</keyword> <ul>
        <li> Method call and <keyword>wait for return</keyword>. </li>
        <li> Represented as full solid arrow. </li>
        <li> Dashed arrow indicated return. </li>
    </ul> </li>

    <li> <keyword>Asynchronous</keyword> <ul>
        <li> Method call <keyword>without return</keyword>. </li>
        <li> Represented as arrow without solid head. </li>
    </ul> </li>
</ul>

<h3 id="reqdoc4"> 7.4 &ndash; About Requirements Documents </h3>
<h4> Users </h4>
<ul>
    <li> System Customers </li>
    <li> Software Managers </li>
    <li> System Engineers </li>
    <li> System Test Engineers </li>
    <li> System Maintenance Engineers </li>
</ul>

<h4> IEEE Requirements Standard </h4>
<p> A useful starting point for defining more detailed specific requirements standards. </p>
<ul>
    <li> Introduction </li>
    <li> General Description </li>
    <li> Specific Requirements </li>
    <li> Appendix </li>
    <li> Index </li>
</ul>

<hr/> <!----------------------------------------------------------------------------------->

<h2 id="reqcap"> 8 &ndash; Requirements Capture </h2>
<h3 id="reqcap1"> 8.1 &ndash; About Requirements Capture </h3>
<p> Involves <keyword>analysts</keyword> working with clients to find out about the application domain, services that the system should provide and the system's operational constraints. May involve <keyword>stakeholders</keyword>. </p>

<h4> Problems with Requirements </h4>
<ul>
    <li> Stakeholders <keyword>don't know what they really want</keyword>. </li>
    <li> Stakeholders express requirements in their <keyword>own terms</keyword>. </li>
    <li> Different stakeholders may have <keyword>conflicting requirements</keyword>. </li>
    <li> Organisational and political factors may <keyword>influence</keyword> the system requirements. </li>
    <li> Requirements <keyword>change</keyword> during the analysis process. </li>
</ul>

<h4> Process Activities </h4>
<ul>
    <li><keyword>Requirements Discovery</keyword><ul>
        <li> <strong>Interacting with stakeholders</strong> to discover their requirements. </li>
    </ul></li>

    <li><keyword>Requirements Classification and Organisation</keyword><ul>
        <li> <strong>Group related requirements</strong> and <strong>organises</strong> them into <strong>coherent clusters</strong>. </li>
    </ul></li>

    <li><keyword>Prioritisation and Negotiation</keyword><ul>
        <li><strong>Prioritising requirements</strong> and <strong>resolving requirement conflicts</strong>.</li>
    </ul></li>

    <li><keyword>Requirements Documentation</keyword><ul>
        <li> Requirements are <strong>documented</strong> and input into next iteration. </li>
    </ul></li>
</ul>

<h3 id="reqcap2"> 8.2 &ndash; Viewpoints </h3>
<p> A way of <keyword>structuring</keyword> the requirements to represent the <keyword>perspectives</keyword> of different stakeholders. Stakeholders may be classified under different viewpoints. </p>

<h3 id="reqcap3"> 8.3 &ndash; Fact-Finding Techniques </h3>
<table>
    <tr>
        <th> Technique </th>
        <th> Definition </th>
        <th> Pros </th>
        <th> Cons</th>
    </tr>
    <tr>
        <td><keyword>Background Reading</keyword></td>
        <td> Company reports, organisation charts, policy manuals of existing systems. </td>
        <td> Helps understand the organisation and prepare for other types of fact finding. </td>
        <td> Written documents often do not match reality; out of date for example. </td>
    </tr>
    <tr>
        <td><keyword>Interviewing</keyword></td>
        <td> A <strong>structured meeting</strong> between the analyst and a stakeholder. </td>
        <td><ul>
            <li> Allows analyst to adapt to what the interviewee says. </li>
            <li> Analyst can probe in <strong>greater depth</strong>.</li>
            <li> Interview can be terminated early if interviewee has nothing to say. </li>
        </ul></td>
        <td><ul>
            <li> Interviews are <strong>time-consuming</strong> and therefore <strong>costly</strong>. </li>
            <li> Results have to be <strong>transcribed or written up</strong> after the interview. </li>
            <li> Can be subject to <strong>bias</strong> if the analyst has a closed mind. </li>
            <li> Different interviewees may provide <strong>conflicting information</strong>. </li>
        </ul></td>
    </tr>
    <tr>
        <td><keyword>Observation</keyword></td>
        <td> Allows the analyst to identify social and organisational factors. </td>
        <td><ul>
            <li> Provides <strong>first-hand</strong> experience of how the current system operates. </li>
            <li> Data collected in <strong>real time</strong> hence having high level of validity. </li>
            <li> Baseline performance data can be collected. </li>
            <li> Can be used to verify other sources of information. </li>
        </ul></td>
        <td><ul>
            <li> Most people don't like being observed and may <strong>behave differently</strong>. </li>
            <li> Required <strong>skilled and trained</strong> observer to be effective. </li>
            <li> Can give rise to <strong>logistical problems</strong>. </li>
            <li> <strong>Ethical issues</strong> can arise if sensitive information is handled. </li>
        </ul></td>
    </tr>
    <tr>
        <td><keyword>Document Sampling</keyword></td>
        <td> Collect copies of blank and completed documents. Analyse the document to determine <strong>inputs and outputs</strong> for each activity. </td>
        <td>Can be used to gather <strong>quantitative data</strong>. Also used to estimate <strong>error rates</strong>.</td>
        <td> Limited use if the system is going to change significantly. </td>
    </tr>
    <tr>
        <td><keyword>Questionnaires</keyword></td>
        <td> Series of written questions with limited range of possible answers. </td>
        <td><ul>
            <li> <strong>Economical method</strong> of gathering data from a large number of people. </li>
            <li> Results can be <strong>analysed easily</strong>. </li>
        </ul></td>
        <td><ul>
            <li> Good questionnaires are difficult to construct. </li>
            <li> May be necessary to <strong>follow up</strong> the questionnaire by an interview. </li>
            <li> May suffer from <strong>low response rates</strong>. </li>
        </ul></td>
    </tr>
</table>

<h3 id="reqcap4"> 8.4 &ndash; Requirements Checking </h3>
<ul>
    <li><keyword>Validity</keyword></li>
    <li><keyword>Consistency</keyword></li>
    <li><keyword>Completeness</keyword></li>
    <li><keyword>Realism</keyword></li>
    <li><keyword>Verifiability</keyword></li>
</ul>

<h3 id="reqcap5"> 8.5 &ndash; Requirements Validation </h3>
<ul>
    <li><keyword>Requirements Reviews</keyword><ul>
        <li> Systematic <strong>manual analysis</strong> of the requirements. </li>
    </ul></li>
    
    <li><keyword>Prototyping</keyword><ul>
        <li> Using an <strong>executable model</strong> of the system to check requirements. </li>
    </ul></li>
    
    <li><keyword>Test-case generation</keyword><ul>
        <li> <strong>Developing tests</strong> for requirements to check testability. </li>
    </ul></li>
</ul>

<hr/> <!----------------------------------------------------------------------------------->

<h2 id="reqana"> 9 &ndash; Requirements Analysis </h2>
<p> To describe requirements and introduce techniques for <keyword>requirements elicitation and analysis</keyword>. </p>

<h4> Phases of RE </h4>
<ul>
    <li><keyword>Early/Inception</keyword><ul>
        <li> Concentrates on the <strong>analysis and modelling</strong> of the environments. </li>
        <li> About the system-to-be, stakeholders, objectives, relationships. </li>
    </ul></li>
    
    <li><keyword>Late/Elaboration</keyword><ul>
        <li> Models the system together with its environment. </li>
        <li> System <strong>requirements and assumptions</strong> about environment are identified. </li>
    </ul></li>
</ul>

<h3 id="reqana1"> 9.1 &ndash; Goal Oriented Requirements Engineering (GORE) </h3>
<ul>
    <li> Focuses on early phase of RE <ul>
        <li> Goal <keyword>elicitation</keyword> </li>
        <li> Goal <keyword>refinement</keyword> </li>
        <li> <keyword>Assigning goals</keyword> to agents </li>
    </ul></li>

    <li> Push requirements to design level. </li>
</ul>

<h4> Benefits of GORE </h4>
<ul>
    <li> <keyword>Wider perspective</keyword> of the system and environment. </li>
    <li> Goals provide a <keyword>rationale</keyword> for requirements. </li>
    <li> Can show whether a requirement specification is <keyword>complete</keyword>. </li>
    <li> Diagrams show <keyword>pertinence</keyword> or relevance of goals.</li>
    <li> Provides <keyword>traceability</keyword> from high level objectives to low level requirements. </li>
    <li> Provides a natural <keyword>structure</keyword>. </li>
    <li> Can help detect <keyword>conflicts</keyword> between goals of different viewpoints. </li>
    <li> Goals tend to be more <keyword>stable</keyword> than requirements. </li>
</ul>

<h3 id="reqana2"> 9.2 &ndash; KAOS </h3>
<p> Either Knowledge Acquisition in autOmated Specification, or Keep All Objects Satisfied. </p>
<p> It is a GORE technique that <keyword>combines</keyword> different types of expression and reasoning. </p>

<table>
    <caption> <strong>KAOS Objects</strong> </caption>
    <tr>
        <th> Object </th>
        <th> Description </th>
    </tr>
    <tr>
        <td><keyword>Operations</keyword></td>
        <td> <strong>Input-output relations</strong> over objects. Declared with signatures having pre-, post- and trigger conditions. </td>
    </tr>
    <tr>
        <td><keyword>Agent</keyword></td>
        <td> Acts as a <strong>processor</strong> for operations. Humans, devices, software, etc. </td>
    </tr>
    <tr>
        <td><keyword>Goal</keyword></td>
        <td> System's <strong>intent</strong>. </td>
    </tr>
</table>

<h4> KAOS Specification </h4>
<p> Consists of three core models: </p>
<ul>
    <li> <keyword>Goal</keyword> </li>
    <li> <keyword>Object</keyword> </li>
    <li> <keyword>Operation</keyword> </li>
</ul>

<h4> Key Ideas </h4>
<ol>
    <li> Build <keyword>requirements model</keyword> </li>
    <li> <keyword>Link</keyword> them with stakeholder high-level goals </li>
    <li> Build <keyword>responsibility model</keyword> </li>
    <li> Build a complete and consistent <keyword>glossary</keyword></li>
    <li> Describe how objects <keyword>behave</keyword> to achieve the goals </li>
    <li> <keyword>Validate requirements</keyword> </li>
    <li> Use a defensive approach by <keyword>identifying obstacles</keyword> </li>
    <li> <keyword>Update model</keyword> as the system develops </li>
</ol>

<img src="images/softeng/reqana1.jpg"/>

<p> This is meant to be a <keyword>directed graph</keyword>. </p>

<img src="images/softeng/reqana2.jpg"/>

<p> An <keyword>obstacle</keyword> is a situation when goal, requirement or expectation is <strong>violated</strong>. </p>

<img src="images/softeng/reqana3.jpg"/>

<h3 id="reqana3"> 9.3 &ndash; MoSCoW </h3>
<ul>
    <li><keyword>Must</keyword><ul>
        <li> Features that <strong>have to be implemented</strong>. </li>
    </ul></li>

    <li><keyword>Should</keyword><ul>
        <li> Features that are <strong>important but not musts</strong>. </li>
    </ul></li>

    <li><keyword>Could</keyword><ul>
        <li> Features that are <strong>nice to have</strong> but not core. </li>
    </ul></li>

    <li><keyword>Won't</keyword><ul>
        <li>Features that are <strong>not</strong> going to be implemented at this stage. </li>
    </ul></li>
</ul>

<hr/> <!----------------------------------------------------------------------------------->

<h2 id="usecase"> 10 &ndash; Use Case </h2>
<h3 id="usecase1"> 10.1 &ndash; Use Case Diagram </h3>
<ul>
    <li><keyword>Actors</keyword><ul>
        <li> People or things that <strong>uses</strong> a computer system. </li>
    </ul></li>
    
    <li><keyword>Use cases</keyword><ul>
        <li> Meaningful pieces of <strong>functionality</strong> provided by a computer system. </li>
    </ul></li>
    
    <li><keyword>Relationships</keyword><ul>
        <li> <strong>Links</strong> between actors and the use case. </li>
        <li> Directed Relationships: <ul>
            <li> Happens when there is a functionality that can be <strong>re-used</strong></li>
            <li> Connecting line with an <strong>arrow</strong> </li>
            <li> <code>&lt;&lt;include&gt;&gt;</code> &ndash; Second use case is <strong>always</strong> invoked by the first. </li>
            <li> <code>&lt;&lt;extend&gt;&gt;</code> &ndash; Second use case is <strong>occasionally</strong> invoked by the first. </li>
        </ul> </li>
    </ul></li>
</ul>
<img src="images/softeng/usecase1.JPG"/>
<img width="600" src="images/softeng/usecase2.jpg"/>

<h4> Finding Use Cases </h4>
<ol>
    <li> <keyword>Map out business process</keyword> using Process maps, Scenario Analysis, Process work flows, etc. </li>
    <li> Ask 'is there a potential use of a computer system here'? </li>
</ol>
<p> The advantage is that the analyst will have to fully consider the <keyword>environment</keyword> before making decisions about system functionality. </p>

<h3 id="usecase2"> 10.2 &ndash; Use Case Description </h3>
<p> Captures <keyword>non-functional requirements</keyword>. </p>
<p> Provides a <keyword>top level view</keyword>, which is for most stakeholders. </p>
<img src="images/softeng/usecase3.jpg"/>
<img src="images/softeng/usecase4.jpg"/>

<hr/> <!----------------------------------------------------------------------------------->

<h2 id="sysdgn"> 11 &ndash; System Design </h2>
<p> <keyword>System Architecture</keyword> is concerned with the <strong>overall structure</strong> of the system and its <strong>interactions</strong> with other systems. System architecture is split between <keyword>software and hardware</keyword> architecture. </p>

<h3 id="sysdgn1"> 11.1 &ndash; Major Activities </h3>
<ol>
    <li> Sub-systems and major <keyword>components</keyword> are identified. </li>
    <li> Any <keyword>inherent concurrency</keyword> is identified. </li>
    <li> Sub-systems are are <keyword>allocated to processors</keyword>. </li>
    <li> <keyword>Data management strategy</keyword> is selected. </li>
    <li> Standards for <keyword>Human Computer Interaction</keyword> is selected. </li>
    <li> <keyword>Code development standards</keyword> are specified. </li>
    <li> <keyword>Control aspects</keyword> of the application are planned. </li>
    <li> <keyword>Test plans</keyword> are produced. </li>
    <li> <keyword>Priorities</keyword> are set for design. </li>
    <li> <keyword>Implementation requirements</keyword> are identified. </li>
</ol>

<h4> Application Types </h4>
<ul>
    <li><keyword>Data Processing Applications</keyword><ul>
        <li> Process data in batches <strong>without explicit user intervention</strong> during the processing. </li>
        <li> Has input-process-output structure. </li>
        <li> E.g. Billing systems; payroll systems. </li>
    </ul></li>

    <li><keyword>Transaction Processing Applications</keyword><ul>
        <li> Process user requests and <strong>update information</strong> in system database. </li>
        <li> E.g. E-commerce; reservation systems. <br/> <img src="images/softeng/sysdgn1.jpg"/> </li>
    </ul></li>

    <li><keyword>Event Processing Systems</keyword><ul>
        <li> System actions depend on <strong>interpreting events</strong> from the system's environment. </li>
        <li> E.g. Word processors; real-time systems. </li>
    </ul></li>

    <li><keyword>Language Processing Systems</keyword><ul>
        <li> User's intentions are specified in a <strong>formal language</strong> that is <strong>processed and interpreted</strong> by the system. </li>
        <li> E.g. Compilers; command interpreters. </li>
    </ul></li>
</ul>

<h3 id="sysdgn2"> 11.2 &ndash; Software Architecture </h3>
<p> No fixed definition. Could be <keyword>class design</keyword> or description of <keyword>sub-systems</keyword> and their relationships. </p>

<h4> Sub-systems </h4>
<p> Collection of system elements that have <keyword>common properties</keyword>. </p>

<h4> Advantages of sub-systems </h4>
<ul>
    <li> Produces <keyword>smaller units of development</keyword>. </li>
    <li> Helps <keyword>maximise reuse</keyword> at a component level. </li>
    <li> Helps developers <keyword>cope</keyword> with complexity. </li>
    <li> Improves <keyword>maintainability</keyword>. </li>
    <li> Aids <keyword>portability</keyword>. </li>
</ul>

<h4> Layering and Partitioning </h4>
<p> There are two method to divide software systems into sub-systems: </p>
<ul>
    <li> Layering <ul>
        <li> Different levels usually represent different levels of abstraction. <br/> <img src="images/softeng/sysdgn2.JPG"/> </li>
        <li> OSI-7 Layer Model <br/> <img width="400" src="images/softeng/sysdgn3.jpg"/> </li>
        <li> Issues: <ul>
            <li> <keyword>Maintaining the stability</keyword> of the interfaces of each layer. </li>
            <li> <keyword>Construction of other systems</keyword> using some of the lower layers.</li>
            <li> Variations in the level of each sub-systems. </li>
            <li> <keyword>Further sub-division</keyword> of complex layers. </li>
            <li> <keyword>Performance reductions</keyword> due to a closed layered architecture. </li>
        </ul></li>
        
        <li> Developing a Layered Architecture <ol>
            <li> Define the <keyword>criteria</keyword>. </li>
            <li> Determine the <keyword>number of layers</keyword>. </li>
            <li> Name the layers and <keyword>assign functionality</keyword>. </li>
            <li> Specify layer's <keyword>services</keyword> </li>
            <li> Refine layering by <keyword>iterating back</keyword> from step 1. </li>
            <li> <keyword>Specify interfaces</keyword> for each layer. </li>
            <li> <keyword>Specify the structure</keyword> of each layer. </li>
            <li> <keyword>Specify the communication</keyword> between layers. </li>
            <li> <keyword>Reduce the coupling</keyword> between adjacent layers. </li>
        </ol></li>
    </ul></li>

    <li> Partitioning <ul>
        <li> Each sub-system focuses on a different aspect of the system functionality. <br/> <img width="600" src="images/softeng/sysdgn4.jpg"/> </li>
        <li> This also depends on the system architect. </li>
    </ul></li>
</ul>

<hr/> <!----------------------------------------------------------------------------------->

<h2 id="pm"> 12 &ndash; Software Project Management Overview </h2>

<h4> <keyword>Project Attributes</keyword> </h4>
<ul>
    <li> Has a unique purpose </li>
    <li> Temporary </li>
    <li> Developed using progressive elaboration </li>
    <li> Requires resources </li>
    <li> Involves uncertainty </li>
</ul>

<h4> <keyword>Triple Constraint</keyword> </h4>
<ul>
    <li> Scope Goal </li>
    <li> Time Goal </li>
    <li> Cost Goal </li>
</ul>

<h4> Project Management <keyword>Knowledge Areas</keyword></h4>
<p> Describe the <keyword>key competencies</keyword> that project managers must develop. </p>
<ul>
    <li> <keyword>Core</keyword> knowledge areas leading to Project Objectives <ul>
        <li> Scope </li>
        <li> Time </li>
        <li> Cost </li>
        <li> Quality </li>
    </ul></li>

    <li> <keyword>Facilitating</keyword> knowledge areas, the means through which the project objectives are achieved <ul>
        <li> Human Resources </li>
        <li> Communication </li>
        <li> Risk </li>
        <li> Procurement Management </li>
    </ul></li>

    <li> <keyword>Affects and is affected</keyword> by all the other knowledge areas <ul>
        <li> Project Integration Management </li>
    </ul></li>
</ul>

<h4> Project Success </h4>
<p> There are several ways to define project success </p>
<ul>
    <li> Meets the <keyword>scope, time and cost goals</keyword>. </li>
    <li> The project <keyword>satisfies the customer</keyword>. </li>
    <li> The results of the project met its <keyword>main objective</keyword>. </li>
</ul>

<h3 id="pm1"> 12.1 &ndash; Software Project Management </h3>
<p> Concerned with activities involving in ensuring that software is <keyword>delivered on time</keyword> in accordance with the requirements of the organisations developing the software. It is needed because software development is always subject to <keyword>budget and schedule constraints</keyword>. </p>

<h4> Management Activities </h4>
<ul>
    <li> Proposal writing </li>
    <li> Project planning and scheduling </li>
    <li> Project costing </li>
    <li> Project monitoring and reviews </li>
    <li> Personnel selection and evaluation </li>
    <li> Report writing and presentations </li>
</ul>

<p> Sometimes it may not be possible to appoint the ideal people to work on a project. It is because the staff could either be <strong>too expensive</strong>, <strong>lack of required skills</strong>, or the organisation just wants to <strong>develop other employees</strong>. </p>

<h4> Project Planning </h4>
<p> It is a <keyword>continuous activity</keyword> from <strong>initial concept</strong> to <strong>system delivery</strong>. Plans must be regularly revised as new information becomes available. </p>

<h4> Types of Project Plan </h4>
<table>
    <tr>
        <th> Plan </th>
        <th> Description </th>
    </tr>
    <tr>
        <td><keyword>Quality Plan</keyword></td>
        <td> Describes quality procedures and standards that will be used in a project. </td>
    </tr>
    <tr>
        <td><keyword>Validation Plan</keyword></td>
        <td> Describes the approach, resources and schedule used for system validation. </td>
    </tr>
    <tr>
        <td><keyword>Configuration Management Plan</keyword></td>
        <td> Describes the configuration management procedures and structures to be used. </td>
    </tr>
    <tr>
        <td><keyword>Maintenance Plan</keyword></td>
        <td> Predicts the maintenance requirements of the system, maintenance costs and effort required. </td>
    </tr>
    <tr>
        <td><keyword>Staff Development Plan</keyword></td>
        <td> Describes how the skills and experience of the project team members will be developed. <br/> <img src="images/softeng/pm6.JPG"/> </td>
    </tr>
</table>

<h3 id="pm2"> 12.2 &ndash; Project Planning Process </h3>
<img src="images/softeng/pm1.JPG"/>

<p> The project plan sets out the resources available to the project, the work breakdown, and a schedule for the work. </p>

<h4> Activity Organisation </h4>
<p> Activities should be organised to produce tangible outputs management to judge progress. </p>
<ul>
    <li><keyword>Milestones</keyword><ul>
        <li> End-point of a process activity. </li>
    </ul></li>

    <li><keyword>Deliverables</keyword><ul>
        <li> Project results delivered to customers. </li>
    </ul></li>
</ul>
<p> The waterfall shows the most obvious definition of progress milestones. </p>
<img src="images/softeng/pm2.JPG"/>

<h4> Project Scheduling </h4>
<ul>
    <li> <keyword>Splitting project</keyword> to tasks and estimate time and resources to complete each task. </li>
    <li> <keyword>Organise tasks concurrently</keyword>. </li>
    <li> <keyword>Minimise task dependencies</keyword> to avoid delays. </li>
    <li> Dependent on project managers intuition and experience. </li>
</ul>
<img src="images/softeng/pm3.JPG"/>

<h4> Scheduling Problems </h4>
<ul>
    <li> It is <keyword>difficult</keyword> to estimate. </li>
    <li> Productivity is <keyword>not proportional</keyword> to the number of people working on a task. </li>
    <li> <keyword>Brook's law</keyword> - Adding people to a late project makes it later because of <keyword>communication overheads</keyword>. </li>
    <li> The unexpected things always happens. </li>
</ul>

<h3 id="pm3"> 12.3 &ndash; Gantt Charts and Activity Networks </h3>
<p> These are graphical notations used to illustrate the project schedule which shows the project breakdown into tasks. </p>

<ul>
    <li> Gantt (bar) charts show <keyword>schedule against calendar time</keyword>. <br/> <img src="images/softeng/pm4.JPG"/> <br/> Milestones can be added to this chart by entering task with zero duration. </li>
    <li> Activity charts show <keyword>task dependencies</keyword> and the <keyword>critical path</keyword>. <br/> <img src="images/softeng/pm4.JPG"/> </li>
</ul>

<h3 id="pm4"> 12.4 &ndash; SMART Criteria </h3>
<p> Milestones should be: </p>
<ul>
    <li> <keyword>S</keyword>pecific </li>
    <li> <keyword>M</keyword>easurable </li>
    <li> <keyword>A</keyword>ssignable </li>
    <li> <keyword>R</keyword>ealistic </li>
    <li> <keyword>T</keyword>ime-framed </li>
</ul>
    
<hr/> <!----------------------------------------------------------------------------------->

<h2 id="risks"> 13 &ndash; Project Risk Management (RM) </h2>
<p> This is about <keyword>identifying</keyword>, <keyword>analysing</keyword> and <keyword>responding</keyword> to risk throughout the life of a project. </p>
<p> It is an <keyword>uncertainty</keyword> that can have a <strong>negative</strong> or <strong>positive</strong> effect on meeting project objectives. </p>

<h4> Negative Risk </h4>
<p> Dictionary definition: <em>Possibility of loss or injury.</em></p>

<p> It involves understanding the <keyword>potential problem</keyword> that might occur in a project and how they might <keyword>impede success</keyword>.</p>

<h4> Positive Risk </h4>
<p> In other words, <keyword>opportunities</keyword> that results in good things happening. </p>

<h4> Risk Utility </h4>
<p> Or risk tolerance, is the amount of <keyword>satisfaction</keyword> received from a potential payoff. </p>

<h3 id="risks1"> 13.1 &ndash; RM Process </h3>
<ol>
    <li><keyword>RM Planning</keyword><ul>
        <li> Deciding how to approach and plan the risk management activities. </li>
        <li> Outputs a <keyword>Risk management plan</keyword> - documents the procedures for managing risk. Topics may include: <ul>
            <li> Methodology </li>
            <li> Roles and responsibilities </li>
            <li> Budget and schedule </li>
            <li> Risk categories </li>
            <li> Risk probability and impact </li>
            <li> Risk documentation </li>
        </ul></li>
    </ul></li>

    <li><keyword>Risk Identification</keyword><ul>
        <li> Determining and documenting possible positive or negative risks. Tools and techniques: <br/>
            <table>
                <tr>
                    <th>Technique</th>
                    <th>Description</th>
                    <th>Pros</th>
                    <th>Cons</th>
                </tr>
                <tr>
                    <td><keyword>Brainstorming</keyword></td>
                    <td> A group attempts to generate ideas by <strong>amassing ideas spontaneously</strong>. </td>
                    <td> Easier, faster and cheaper to conduct. </td>
                    <td> Not anonymous, can be biased, group effect may inhibit idea generation. </td>
                </tr>
                <tr>
                    <td><keyword>Delphi Technique</keyword></td>
                    <td> Used to derive a <strong>consensus</strong> among a those who predicts about future developments by using repeated rounds of <strong>questioning</strong> and <strong>written responses</strong>. </td>
                    <td> Keep inputs anonymous, avoids bias and political problems. </td>
                    <td> May be slow and more expensive as this requires a moderator. </td>
                </tr>
                <tr>
                    <td><keyword>Interviewing</keyword></td>
                    <td> To <strong>collect information</strong> in face-to-face, phone, or other communication services. </td>
                    <td> Quick to receive information by phone or in person. Effective when interviewing person who has experience related to the project. </td>
                    <td> People may refuse to participate, prone to bias. </td>
                </tr>
                <tr>
                    <td><keyword>SWOT Analysis</keyword></td>
                    <td> <strong>Strengths</strong>, <strong>Weaknesses</strong>, <strong>Opportunities</strong> and <strong>Threats</strong> analysis. Helps identify the broad negative and positive risks. </td>
                    <td> It is simple and anybody can do it quickly. </td>
                    <td> No weighting factors, prone to ambiguity, prone to bias. </td>
                </tr>
            </table>
        </li>
        <li> Outputs a <strong>Risk Register</strong> which is a document that contains a list of identified risk and other information. For each risk events, it has: <ul>
            <li> ID no. and name </li>
            <li> Rank and priority </li>
            <li> Description </li>
            <li> Category </li>
            <li> Root cause </li>
            <li> Triggers </li>
            <li> Potential responses </li>
            <li> Person who will be responsible to handle risk </li>
            <li> Probability and impact </li>
            <li> Status </li>
        </ul></li>
    </ul></li>

    <li><keyword>Qualitative Risk Analysis</keyword><ul>
        <li> Prioritising risks based on its probability and impact. </li>
        <li> Techniques: <ul>
            <li> Probability/Impact matrices <ul>
                <li><img src="images/softeng/risks1.JPG"/></li>
            </ul></li>
            <li> The Top Ten Risk Item Tracking <ul>
                <li><img src="images/softeng/risks2.JPG"/></li>
            </ul></li>
            <li> Expert Judgement </li>
        </ul></li>
    </ul></li>

    <li><keyword>Quantitative Risk Analysis</keyword><ul>
        <li> Numerically estimating the effects of risks. </li>
        <li> Techniques: <ul>
            <li> Decision Tree Analysis <ul>
                <li> A <strong>decision tree</strong> is a diagram analysis technique to help select the best course of action in situations where outcomes are uncertain. </li>
                <li> <strong>Estimated Monetary Value (EMV)</strong> is the product of a risk event probability and the risk event's monetary value. </li>
                <li><img src="images/softeng/risks3.JPG"/></li>
            </ul></li>
            <li> Simulation </li>
            <li> Sensitivity Analysis </li>
        </ul></li>
    </ul></li>

    <li><keyword>Risk Response Planning</keyword><ul>
        <li> How to respond to risks. Work on enhancing opportunities and reduce threats. </li>
        <li> Strategies for Negative Risks <ul>
            <li> Risk avoidance </li>
            <li> Risk acceptance </li>
            <li> Risk transference </li>
            <li> Risk mitigation </li>
        </ul></li>
        <li> Strategies for Positive Risks <ul>
            <li> Risk exploitation: Make sure positive risk happens </li>
            <li> Risk sharing: Allocate ownership of risk to others </li>
            <li> Risk enhancement: Maximise key drivers of positive risk </li>
            <li> Risk acceptance </li>
        </ul></li>
    </ul></li>

    <li><keyword>Risk Monitoring and Control</keyword><ul>
        <li> Monitoring risks </li>
        <li> Identifying new risks </li>
        <li> Carry out risk response plans </li>
        <li> Evaluate risk strategy </li>
    </ul></li>
</ol>

<p> A <strong>Risk Breakdown Structure</strong> is a hierarchy of potential risk categories. </p>

<hr/> <!----------------------------------------------------------------------------------->

<h2 id="quality"> 14 &ndash; Software Quality Management </h2>
<p> Concerned with ensuring that the <keyword>required level of quality is achieved</keyword> in a software product. It involves defining appropriate <strong>quality standards</strong> and <strong>procedures</strong> to follow. </p>

<p> <keyword>Quality</keyword> means that a product should <strong>meet its specification</strong>. </p>
<p> For large systems, the quality documentation is a record of progress and supports <keyword>continuity of development</keyword>. For smaller systems, quality management needs less documentation and should focus on establishing a <keyword>quality culture</keyword>. </p>

<h3 id="quality1"> 14.1 &ndash; Quality Management (QM) Activities </h3>
<ul>
    <li><keyword>Quality Assurance</keyword><ul>
        <li> <strong>Establish</strong> organisational procedures and standards for quality. </li>
    </ul></li>
    
    <li><keyword>Quality Planning</keyword><ul>
        <li> <strong>Select</strong> applicable procedures and standards, then <strong>modify</strong> as required. </li>
    </ul></li>
    
    <li><keyword>Quality Control</keyword><ul>
        <li> Ensure that procedures and standards are <strong>followed</strong>. </li>
    </ul></li>
</ul>
<p> The quality management should be <strong>separate</strong> from project management to ensure <strong>independence</strong>. </p>

<h4> Process based quality </h4>
<ul>
    <li> The quality of a developed product is influenced by the quality of the production process. </li>
    <li> There is a link between process and product. </li>
    <li> For software development, the application of individual skills and experience makes a significant difference. </li>
    <li> External factors like the need to rush development may impair product quality. </li>
</ul>
<img src="images/softeng/quality1.JPG"/>

<h3 id="quality2"> 14.2 &ndash; Standards </h3>
<p> Define process standards such as how reviews should be conducted, configuration, management, etc. </p>
<p> Standards are the key to effective quality management. </p>
<ul>
    <li><keyword>Product standards</keyword> &ndash; characteristics that all components should exhibit. e.g. a programming style. </li>
    <li><keyword>Process standards</keyword> &ndash; how the software process should be enacted. </li>
</ul>

<h4> The Importance of Standards </h4>
<ul>
    <li> <strong>Avoids repetition</strong> of past mistakes. </li>
    <li> Acts as a <strong>framework</strong> for quality assurance process. </li>
    <li> Provides <strong>continuity</strong> for new staff. </li>
</ul>

<h4> Product and Process Standards example </h4>
<table>
    <tr>
        <td><keyword>Product Standards</keyword></td>
        <td><keyword>Process Standards</keyword></td>
    </tr>
    <tr>
        <td> Design review form </td>
        <td> Design review conduct </td>
    </tr>
    <tr>
        <td> Requirements document structure </td>
        <td> Submission of documents </td>
    </tr>
    <tr>
        <td> Method header format </td>
        <td> Version release process </td>
    </tr>
    <tr>
        <td> Java programming style </td>
        <td> Project plan approval process </td>
    </tr>
    <tr>
        <td> Project plan format </td>
        <td> Change control process </td>
    </tr>
    <tr>
        <td> Change request form </td>
        <td> Test recording process </td>
    </tr>
</table>

<h4> Problems with Standards </h4>
<p> These days, it may not seem that relevant and updated by software engineers. It involves too much tedious form filling. Even worse if there are no supporting tools to help this form creating or filling. </p>

<h4> Documentation Standards </h4>
<p> There are three types of standards: </p>
<ul>
    <li> Documentation <keyword>process standards</keyword><ul>
        <li> How documents should be developed, validated and maintained. </li>
        <li> <img src="images/softeng/quality2.JPG"/> </li>
    </ul></li>
    <li> Documentation <keyword>standards</keyword><ul>
        <li> Document <strong>Identification standards</strong>: The unique identification. </li>
        <li> Document <strong>structure standards</strong>: Standard structure for project documents. </li>
        <li> Document <strong>presentation standards</strong>: Fonts, styles, logos, etc. </li>
        <li> Document <strong>update standards</strong>: How changes from previous versions are reflected. </li>
    </ul></li>
    <li> Documentation <keyword>interchange standards</keyword><ul>
        <li> Compatibility of electronic documents. </li>
        <li> This allows electronic documents to be exchanged, mailed, etc. </li>
        <li> Need to define conventions for use. </li>
        <li> Need for archiving for future access. </li>
    </ul></li>
</ul>

<h3 id="quality3"> 14.3 &ndash; Quality Plans </h3>
<p> Defines the quality assessment process. </p>
<p> The quality plan structure includes: </p>
<ul>
    <li> Product intro </li>
    <li> Product plans </li>
    <li> Process descriptions </li>
    <li> Quality goals </li>
    <li> Risks and risk management </li>
</ul>
<p> Should be short and succinct or else nobody will read them. </p>

<h4> Quality Control </h4>
<p> Involves checking the software development process to ensure they are being followed. </p>
<ul>
    <li> <keyword>Quality reviews</keyword><ul>
        <li> Principle method of <strong>validating product</strong> or <strong>process quality</strong>. </li>
        <li> Types of reviews: <ul>
            <li> Inspections for <keyword>defect removal</keyword> for product </li>
            <li> Reviews for <keyword>progress assessment</keyword> for product and process </li>
            <li> <keyword>Quality reviews</keyword> for product and standards <ul>
                <li> A group of people examines a part of the software system and its documentation. </li>
            </ul></li>
            <li> Design inspections </li>
            <li> Progress reviews </li>
        </ul></li>
        <li> Review results </li>
    </ul></li>
    <li> Automated software <keyword>assessment</keyword> and <keyword>measurement</keyword> </li>
</ul>

<h3 id="quality4"> 14.4 &ndash; Software Measurement and Metrics </h3>
<p> <keyword>Software Measurement</keyword> is concerned with deriving a numeric value for an attribute of a software product or process. This allows objective comparisons between techniques and processes. E.g. lines of code, fog index. </p>

<p> <keyword>Software Metric</keyword> is any type of measurement which relates to a software system, process or documentation. </p>
<p> There are two types of software metrics </p>
<ul>
    <li><keyword>Process metrics</keyword><ul>
        <li> Attributes of the <strong>process</strong> such as time taken to complete a task. </li>
        <li> Used to control software process. </li>
    </ul></li>
    <li><keyword>Product metrics</keyword><ul>
        <li> Attributes of the <strong>software</strong> such as its complexity. </li>
        <li> USed for general predictions or to identify anomalous components. </li>
        <li> Consists of classes: <ul>
            <li><keyword>Dynamic metrics</keyword><ul>
                <li> Collected measurements in execution. </li>
                <li> Help assess efficiency and reliability. </li>
                <li> Closely related to software quality attributes. </li>
                <li> E.g. it is relatively easy to measure the response time of a system (performance attribute). </li>
            </ul></li>
            <li><keyword>Static metrics</keyword><ul>
                <li> Collected measurements by system representations. </li>
                <li> Help assess complexity and maintainability. </li>
                <li> Have an indirect relationship with quality attributes. </li>
            </ul></li>
        </ul></li>
    </ul></li>
</ul>

<h4> Metric Assumptions </h4>
<p> This metric assumes that a software property can be <keyword>measured</keyword>. It also assumes that a <keyword>relationship exists</keyword> between what we can measure and what we want to know. This relationship is assumed to have been <keyword>formalised</keyword> and <keyword>validated</keyword>. </p>

<h4> Measurement Process </h4>
<p> Software measurement process may be part of a quality control process. Data collected during this process should be maintained as an organisational resource. Once a measurement database has been established, comparisons across projects become possible.</p>
<ul>
    <li><keyword>Goal</keyword><ul>
        <li> What the organisation is trying to achieve. </li>
    </ul></li>

    <li><keyword>Question</keyword><ul>
        <li> Questions about areas of uncertainty related to the goals. </li>
    </ul></li>

    <li><keyword>Metric</keyword><ul>
        <li> Measurements to be collected to answer the questions. </li>
    </ul></li>
</ul>

<p> A metrics program should be based ona set of product and process data. Data should be collected immediately with any of these three types of automatic data collection: </p>
<ul>
    <li><keyword>Static product analysis</keyword></li>
    <li><keyword>Dynamic product analysis</keyword></li>
    <li><keyword>Process data collation</keyword></li>
</ul>

<hr/> <!----------------------------------------------------------------------------------->

<h2 id="config"> 15 &ndash; Software Configuration Management </h2>
<p> <keyword>Configuration management</keyword> (CM) is concerned with <strong>managing evolving software systems</strong>. It involves the development and application of procedures and standards to manage an evolving software product. Should always be based on a <strong>set of standards</strong> which are applied within an organisation. </p>

<p> CM maybe seen as part of a more general quality management process. When released to CM, software systems are called <em>baselines</em> as they are a starting point for further development. </p>

<h3 id="config1"> 15.1 &ndash; Configuration Management Planning </h3>
<p> All products of the software process (specifications, designs, programs, test data, user manuals) may have to be managed along with its documentations. </p>
<p> <keyword>CM plan</keyword> defines: </p>
<ul>
    <li> Types of documents to be <keyword>managed</keyword> and <keyword>named</keyword>. </li>
    <li> Who takes responsibility for the CM procedures and creation of baselines. </li>
    <li> Policies for <keyword>change control</keyword> and <keyword>version management</keyword>. </li>
    <li> The CM records which must be maintained. </li>
    <li> The tools to be used. </li>
    <li> The process of tool use. </li>
    <li> The CM <keyword>database</keyword> used to record configuration information. </li>
    <li> Other relevant information. </li>
</ul>

<h4> Configuration Item Identification </h4>
<p> Large project typically produce large numbers of documents which must be uniquely identified. Document naming scheme should be defined so related documents have related names. </p>

<p> Hence a hierarchical scheme with multi-level names is the most flexible solution. <br> E.g. <code>PCL-TOOLS/EDIT/FORMS/DISPLAY/AST-INTERFACE/CODE</code></p>

<h3 id="config2"> 15.2 &ndash; Change Management </h3>
<p> Software systems are subject to continual <keyword>change requests</keyword> from <strong>users</strong>, <strong>developers</strong> and <strong>market forces</strong>. </p>
<p> Change management is concerned with keeping track of these changes and ensuring that they are implemented in the most cost-effective way. </p>

<h4> Change Management Process </h4>
<img src="images/softeng/config1.JPG"/>

<h4> Change Request Form </h4>
<p> This is also part of the CM planning process. It records the <strong>change proposed</strong>, <strong>requestor</strong> of change, the <strong>change reason</strong>, and the <strong>urgency</strong> of change. Also has other things. </p>
<img src="images/softeng/config2.JPG"/>
<p> Since managing and <keyword>tracking change</keyword> is a big problem, <strong>tools</strong> that can help resolve this is often used. </p>

<h4> Change Control Board </h4>
<p> Changes should be review by an <keyword>external group</keyword> who decide whether or not they are <strong>cost-effective</strong> from a strategic viewpoint. This group should be independent of project and responsible for the system. </p>

<h4> Derivation History </h4>
<p> This is a <keyword>record of changes</keyword> applied to a document or code component. </p>

<h3 id="config3"> 15.3 &ndash; Version Management </h3>
<ul>
    <li> An <keyword>identification scheme</keyword> for system versions is required. </li>
    <li> Plan when a <keyword>new system version</keyword> is to be produced. </li>
    <li> Ensure that version management procedures and tools are properly applied. </li>
    <li> Plan and distribute <keyword>system release</keyword>. </li>
</ul>

<ul>
    <li><keyword>Version</keyword><ul>
        <li> An instance of a system which is <strong>functionally distinct</strong> in some way from other system instances. </li>
    </ul></li>

    <li><keyword>Variant</keyword><ul>
        <li> An instance of a system which is functionally identical but <strong>non-functionally distinct</strong> from other instances of a system. </li>
    </ul></li>

    <li><keyword>Release</keyword><ul>
        <li> An instance of a system which is <strong>distributed to users</strong> outside the development team. </li>
    </ul></li>
</ul>

<h4> Component Identification Techniques: </h4>
<ul>
    <li><keyword>Version Numbering</keyword><ul>
        <li> Simple naming scheme uses a <strong>linear derivation</strong>. E.g. V1, V1.1, V1.2, V2.1, ... </li>
        <li> Limitations: <ul>
            <li> Actual derivation becomes a tree rather than a sequence. </li>
            <li> Names are not meaningful. </li>
        </ul></li>
    </ul></li>

    <li><keyword>Attribute-based Identification</keyword><ul>
        <li> <strong>Attributes</strong> can be <strong>associated</strong> with a version with the combination of attributes identifying that version. E.g. Date, Creator, Programming Language, etc. </li>
        <li> Advantages: <ul>
            <li> This is <keyword>more flexible</keyword> than an explicit naming scheme. </li>
            <li> Can <keyword>support queries</keyword>, so its easy to search and sort versions. </li>
        </ul></li>
        <li> Limitation: <ul>
            <li> May have problems with <keyword>uniqueness</keyword>. </li>
        </ul></li>
    </ul></li>

    <li><keyword>Change-oriented Identification</keyword><ul>
        <li> <keyword>Integrates</keyword> versions and the changes made to create these versions. </li>
        <li> This is <keyword>used for systems</keyword> rather than components. </li>
        <li> Each proposed change has a <keyword>change set</keyword> that describes changes made to implement that change. </li>
        <li> Change sets are <keyword>applied in sequence</keyword>. </li>
    </ul></li>
</ul>

<h3 id="config4"> 15.4 &ndash; Release Management </h3>
<p> Releases <keyword>must incorporate changes</keyword> forced on the system by errors discovered and hardware changes. Also must incorporate <keyword>new system functionality</keyword>. </p>

<p> <keyword>System release</keyword> is not just a set of executable programs, and may include any other relevant things about the system. E.g. installation program or script. </p>

<p> Customers, however, may not want new releases of the system because they are already happy with their current system. </p>

<p> When <keyword>making decision</keyword> to release a system, there are some factors to consider: </p>
<ul>
    <li> Preparing and distributing a system release is <strong>expensive</strong> </li>
    <li> Competition, marketing requirements </li>
    <li> Technical quality of the system </li>
    <li> Customer change request </li>
</ul>

<h4> System Release Strategy </h4>
<img src="images/softeng/config3.JPG"/>
<p> The <keyword>release criterion</keyword> involves collecting all files and documentation required to create a system release. </p>

<h3 id="config5"> 15.5 &ndash; System Building </h3>
<p> The process of <strong>compiling and linking</strong> software components into an <keyword>executable system</keyword>. Different systems are built from different combinations of components. </p>

<p> Factors to be considered <keyword>when building a system</keyword>: </p>
<ul>
    <li> Do the build instructions include all required components? </li>
    <li> Is the appropriate component version specified? </li>
    <li> Are all data files available? </li>
</ul>

<p> System building problems to be considered: </p>
<ul>
    <li> Are data file references within components correct? </li>
    <li> Is the system being built for the right platform? </li>
    <li> Is the right version of the compiler and other software tools specified? </li>
</ul>

<p> <keyword>CASE Tools</keyword> aid all configuration management activities. </p>
<ul>
    <li><keyword>Change Management</keyword> Tools<ul>
        <li> Form editor </li>
        <li> Workflow system - to define responsibilities. </li>
        <li> Change database tool </li>
        <li> Change reporting system </li>
    </ul></li>

    <li><keyword>Version Management</keyword> Tools<ul>
        <li> Version and release identification </li>
        <li> Storage management - stores differences between versions, <em>delta</em>s. </li>
        <li> Change history recording </li>
        <li> Independent development - change only one version at a time. </li>
        <li> Project support - Can manage groups of files associated with a project. </li>
    </ul></li>

    <li><keyword>System Building</keyword> Tools may provide: <ul>
        <li> Dependency specification language and interpreter </li>
        <li> Tool selection and instantiation support </li>
        <li> Distributed compilation </li>
        <li> Derived object management </li>
    </ul></li>
</ul>

<hr/> <!----------------------------------------------------------------------------------->

<h2 id="interface"> 16 &ndash; User Interface Design </h2>
<h4> User Interface </h4>
<p> Should be designed to <keyword>match</keyword> the skills, experience and expectations of anticipated users. </p>
<p> Human factors should be considered when designing interfaces. Some include: </p>
<ul>
    <li> Limited short-term memory </li>
    <li> People make mistakes </li>
    <li> People are different and have different capabilities </li>
    <li> People have different interaction preferences </li>
</ul>

<h3 id="interface1"> 16.1 &ndash; Design Principles </h3>
<ul>
    <li><keyword>User Familiarity</keyword><ul>
        <li> Interface should be based on user-oriented terms and concepts rather than computer concepts. </li>
    </ul></li>

    <li><keyword>Consistency</keyword><ul>
        <li> The system should display an appropriate level of consistency in the format of menus, commands, language, etc. </li>
    </ul></li>

    <li><keyword>Minimal Surprise</keyword><ul>
        <li> The user should be able to predict the operation of comparable commands. </li>
    </ul></li>

    <li><keyword>Recoverability</keyword><ul>
        <li> The system should provide some resilience to user errors and allow them to recover from errors. </li>
    </ul></li>

    <li><keyword>User Guidance</keyword><ul>
        <li> Some user guidance like help systems, manuals or tutorials should be supplied. </li>
    </ul></li>

    <li><keyword>User Diversity</keyword><ul>
        <li> Interaction facilities for different types of user (including disabled) should be supported. </li>
    </ul></li>
</ul>

<p> There are two <keyword>design issues in UI</keyword>s that must be addressed. The designer must know how will information from the user be fed to the computer system, and how should information from the computer system be presented to the user. </p>
<p> This can be solved using a coherent framework such as a user interface <keyword>metaphor</keyword>, which incldues <strong>dialogue between user and system</strong>, and <strong>direct manipulation</strong>. </p>

<h4> Interaction Styles </h4>
<table>
    <tr>
        <th>Interaction style</th>
        <th>Pros</th>
        <th>Cons</th>
        <th>Application Examples</th>
    </tr>
    <tr>
        <td><keyword>Direct Manipulation</keyword></td>
        <td>Fast and intuitive interaction which is easy to learn.</td>
        <td>May be hard to implement.<br>Only suitable in cases that have visual metaphor for tasks and objects.</td>
        <td>Video games, CAD Systems</td>
    </tr>
    <tr>
        <td><keyword>Menu Selection</keyword></td>
        <td>Avoids user error.<br>Little typing required.</td>
        <td>Slow for experienced users.<br>Can be complex if there are many menu options.</td>
        <td>Most general-purpose systems</td>
    </tr>
    <tr>
        <td><keyword>Form fill-in</keyword></td>
        <td>Simple data entry.<br>Easy to learn.<br>Checkable.</td>
        <td>Takes up a lot of screen space.<br>Causes problems where user options do not match the form.</td>
        <td>Stock control, personal loan processing</td>
    </tr>
    <tr>
        <td><keyword>Command Language</keyword></td>
        <td>Powerful and flexible</td>
        <td>Hard to learn.<br>Poor error management.</td>
        <td>Operating systems, command and control systems</td>
    </tr>
    <tr>
        <td><keyword>Natural Language</keyword></td>
        <td>Accessible to casual users.<br>Easily extended.</td>
        <td>Requires more typing.<br>Natural language understanding systems are unreliable.</td>
        <td>Information retrieval systems</td>
    </tr>
</table>

<h3 id="interface2"> 16.2 &ndash; UI Design Process </h3>
<p> Designing is an <keyword>iterative process</keyword> involving close liaisons between <strong>users</strong> and <strong>designers</strong>. </p>
<p> There are three core activities in this process: </p>
<ul>
    <li><keyword>User analysis</keyword><ul>
        <li> Understand what users will do with the system. </li>
    </ul></li>

    <li><keyword>System prototyping</keyword><ul>
        <li> Develop a series of prototypes for experiment. </li>
    </ul></li>

    <li><keyword>Interface evaluation</keyword><ul>
        <li> Study users working with these prototypes to evaluate and modify them. </li>
    </ul></li>
</ul>

<h4> User Analysis </h4>
<p> <keyword>User analysis</keyword> has to be described in terms that <strong>users</strong> and <strong>other designers can understand</strong>. Scenarios to describe typical episodes of use are one way of describing these analyses. </p>
<p> Techniques: </p>
<ul>
    <li><keyword>Hierarchical Task Analysis</keyword> - <strong>Model</strong> the steps involved in completing a task. </li>
    <li><keyword>Interviewing and Questionnaires</keyword> - <strong>Ask</strong> the users about the work they do. <ul>
        <li> Design semi-structured interviews based on open-ended questions. </li>
        <li> Users provide information that they think is essential. </li>
        <li> Group interviews or focus groups allow users to discuss with each other what they do. </li>
    </ul></li>
    <li><keyword>Ethnography</keyword><ul>
        <li> <strong>Observe</strong> the user at work. </li>
        <li> Valuable because many user tasks are intuitive and may be difficult to describe and explain. </li>
        <li> Helps understand the role of social and organisational influences on work. </li>
    </ul></li>
</ul>

<h4> User Interface Prototyping </h4>
<p> The aim of prototyping is to allow users to <keyword>gain direct experience</keyword> with the interface. Or else it would have been impossible to judge the <keyword>usability</keyword> of an interface. </p>
<p> Prototyping may be a two-stage process: </p>
<ul>
    <li> <keyword>Early in the process</keyword>, paper prototypes <ul>
        <li> Work through scenarios using sketches of the interface, or base it on hierarchical task analysis. </li>
        <li> Use a <keyword>storyboard</keyword>. </li>
        <li> This is an effective way of getting user reactions to a design proposal. </li>
    </ul></li>
    <li> The design is then refined and increasingly sophisticated <keyword>automated prototypes</keyword> are then developed. Very useful for ethnographics studies. </li>
</ul>

<h4> User Interface Evaluation </h4>
<p> Evaluation of UIs should be carried out to assess its suitability. We want to know if the interface will be <keyword>usable</keyword> or not, or in other words, whether it meets the <keyword>functional requirements</keyword>. </p>

<p> Usability Attributes </p>
<ul>
    <li><keyword>Learnability</keyword></li>
    <li><keyword>Speed of Operation</keyword></li>
    <li><keyword>Robustness</keyword></li>
    <li><keyword>Recoverability</keyword></li>
    <li><keyword>Adaptability</keyword></li>
</ul>

<p> Simple Evaluation Techniques </p>
<ul> 
    <li> <strong>Questionnaires</strong> for user feedback. </li>
    <li> <strong>Video recording</strong> of system use and subsequent tape evaluation. </li>
    <li> <strong>Instrumentation of code</strong> to collect information about facility use and user errors. </li>
    <li> The <strong>provision of code</strong> in the software to collect online user feedback. </li>
</ul>

<hr/> <!----------------------------------------------------------------------------------->

<h2 id="distribute"> 17 &ndash; Distributed Systems Architecture </h2>
<h4> Distributed Systems </h4>
<p> Information processing is <keyword>distributed</keyword> over several computers rather than confined to a single machine. </p>
<p> It is very important for <keyword>enterprise</keyword> computing systems. </p>

<table>
    <tr>
        <th colspan="2"><keyword>Pros</keyword></th>
        <th colspan="2"><keyword>Cons</keyword></th>
    </tr>
    <tr>
        <th>Topic</th>
        <th>Description</th>
        <th>Topic</th>
        <th>Description</th>
    </tr>
    <tr>
        <td><keyword>Resource Sharing</keyword></td>
        <td>Sharing of hardware and software resources. </td>
        <td><keyword>Complexity</keyword></td>
        <td>Typically are more complex than centralised systems. </td>
    </tr>
    <tr>
        <td><keyword>Openness</keyword></td>
        <td> Use of equipment and software from different vendors. </td>
        <td><keyword>Security</keyword></td>
        <td> More susceptible to external attacks. </td>
    </tr>
    <tr>
        <td><keyword>Concurrency</keyword></td>
        <td> Concurrent processing to enhance performance. </td>
        <td><keyword>Manageability</keyword></td>
        <td> More effort is required to manage the system. </td>
    </tr>
    <tr>
        <td><keyword>Scalability</keyword></td>
        <td> Increased throughput by adding new resources. </td>
        <td><keyword>Unpredictability</keyword></td>
        <td> Unpredictable responses depending on the system organisation and network load. </td>
    </tr>
    <tr>
        <td><keyword>Fault tolerance</keyword></td>
        <td>The ability to continue in operation after a fault has occurred. </td>
        <td><keyword></keyword></td>
        <td></td>
    </tr>
</table>

<h3 id="distribute1"> 17.1 &ndash; Architecture Categorisation </h3>
<ul>
    <li><keyword>Client-server</keyword><ul>
        <li> Distributed services which are <strong>called on by clients</strong>. Servers that provide services are treated differently from clients that use services. </li>
        <li><keyword>Thin-Client Model</keyword><ul>
            <li> All the application processing and data management is <strong>carried out on the server</strong>. The client is simply responsible for running the presentation software. </li>
            <li>  Used when <strong>legacy</strong> (old) systems are migrated to client-server architectures. The legacy system acts as a server on its own. </li>
            <li> A major disadvantage is that it places a <strong>heavy processing load</strong> on both the <strong>server</strong> and the <strong>network</strong>. </li>
        </ul></li>
        <li><keyword>Fat-Client Model</keyword><ul>
            <li> More processing is delegated to the <strong>client</strong> as the application processing is <strong>locally executed</strong>. Most suitable for new client-server systems where the capabilities of the client system are known in advance. </li>
            <li> It is more complex and hence <strong>harder to manage</strong> than thin-client models. </li>
            <li> It will have security issues and are more <strong>vulnerable to attacks</strong>. </li>
        </ul></li>
    </ul></li>

    <li><keyword>Distributed object</keyword><ul>
        <li> <strong>No distinction</strong> between clients and servers. </li>
        <li> Any objects on the system may provide and use services from other objects. Communication is through a <strong>middleware system</strong>, called an object request broker. </li>
        <li> Advantages: <ul>
            <li> Allows the system designer to <keyword>delay decisions</keyword> on where and how the service should be provided. </li>
            <li> <keyword>Open architecture</keyword> that allows new resources to be added to it. </li>
            <li> System is flexible and scalable. </li>
            <li> It is possible to reconfigure the system <keyword>dynamically</keyword>. </li>
        </ul></li>
        <li> Uses: <ul>
            <li> As a <keyword>logical model</keyword> that allows system organisation. </li>
            <li> As a flexible approach to the <keyword>implementation</keyword> of client-server systems. </li>
        </ul></li>
    </ul></li>
</ul>

<p> A <keyword>middleware</keyword> is a software that manages and supports different components of a distributed system. It sits in the middle of the system and is usually off-the-shelf. </p>
<p> The <keyword>CORBA</keyword> standards are a set of middleware standards that support distributed object architectures. </p>

<h4> Multiprocessor Architectures </h4>
<p> The simplest distributed system model. </p>
<p> Composed of <keyword>multiple processors</keyword> which may <keyword>execute</keyword> on <keyword>different processors</keyword>. </p>
<p> Distribution of process to processors may be pre-ordered or may be under the control of a dispatcher. </p>
<p> E.g. Multiprocessor Traffic Control System. </p>

<h4> Inter-organisational Computing </h4>
<p> For security and inter-operability reasons, most distributed computing has been implemented at enterprise level. Local standards, management and operational processes apply. </p>

<h4> Peer-to-Peer (p2p) Architectures </h4>
<p> Are <keyword>decentralised systems</keyword> where computations may be carried out by <keyword>any node</keyword> in the network. </p>
<p> The overall system is designed to take advantage of computational power and storage of large number networked computers. </p>
<img src="images/softeng/distribute1.JPG"/>

<h4> Service-oriented Architectures </h4>
<p> Based around the notion of <keyword>externally provided services</keyword> (web services). </p>
<p> A web service is a standard approach to making a reusable component available and accessible across the web. </p>
<img src="images/softeng/distribute2.JPG"/>

<p> Services are based on agreed, XML based standards so can be provided on any platform and written in any programming language. Some key standards include: </p>
<ul>
    <li> <keyword>SOAP</keyword> - Simple Object Access Protocol </li>
    <li> <keyword>WSDL</keyword> - Web Services Description Language </li>
    <li> <keyword>UDDI</keyword> - Universal Description, Discovery and Integration </li>
</ul>

<h3 id="distribute2"> 17.2 &ndash; Implementation Diagrams </h3>
<ul>
    <li> UML <keyword>Component Diagrams</keyword> <ul>
        <li> Used to document dependencies between components, typically files, either compilation dependencies or run-time dependencies. </li>
    </ul></li>
    <li> UML <keyword>Deployment Diagrams</keyword> <ul>
        <li> Used to the configuration of run-time processing elements and the software components and processes that are located on them. </li>
        <li> Consists of <ul>
            <li> Nodes - <keyword>Rectangular Prism</keyword>, represent processors, devices or other resources. </li>
            <li> Communication Associations - <keyword>Lines between nodes</keyword>, represent communication between nodes that can be stereotyped. <br/> <img src="images/softeng/distribute3.JPG"/> </li>
        </ul></li>
    </ul></li>
</ul>

<hr/> <!----------------------------------------------------------------------------------->

<h2 id="semanticweb"> 18 &ndash; Semantic Web Introduction </h2>
<h4> The Internet </h4>
<p> <keyword>Internet</keyword> is formed by the co-operative interconnection of a large number of computer network. It is a <strong>network of networks</strong> and <strong>nobody owns</strong> it. Every person who makes a connection owns a slice of the internet, there is no central administration to it. </p>

<p> Internet let computers <strong>share programs</strong> and <strong>information</strong>. </p>

<p> The <keyword>Syntactic web</keyword> is a place where computers do the presentation (easy work) and people do the linking and interpreting (hard work). </p>

<p> In the current web, Markup only consists of <keyword>rendering information</keyword> Hyper-links to related content. Semantic content is accessible but <em>not</em> to computers. </p>

<h4> Semantic Web </h4>
<p> Make web resources more accessible to automated processes. </p>
<ul>
    <li> Extend existing rendering markup with <keyword>semantic markup</keyword>, which are metadata annotations that describe content or function of web accessible resources. </li>
    <li> Use ontology to provide <keyword>vocabulary</keyword> for annotations. It represent human's knowledge for computers. </li>
    <li> OWL is a W3C standard - Web Ontology Language </li>
</ul>

<p> Semantic Web is the next generation of the Web where machines can understand the content of the Web. </p>


<hr/> <!----------------------------------------------------------------------------------->
Good luck for exams!

<!-- Utils -->
<button onclick="topFunction()" id="topBtn" title="Go to top">Top</button>
<script>
    // When the user scrolls down 20px from the top of the document, show the button
    window.onscroll = function () {
        scrollFunction()
    };

    function scrollFunction() {
        if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
            document.getElementById("topBtn").style.display = "block";
        } else {
            document.getElementById("topBtn").style.display = "none";
        }
    }

    // When the user clicks on the button, scroll to the top of the document
    function topFunction() {
        document.body.scrollTop = 0;
        document.documentElement.scrollTop = 0;
    }
</script>
<button onclick="window.location.href='index.html'" id="homeBtn" title="Back to Home"> Home</button>
</body>
</html>