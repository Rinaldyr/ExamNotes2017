<!DOCTYPE html>
<html lang="en">
<head>
    <!--[if lt IE 9]>
    <script> document.createElement("keyword"); </script>
    <![endif]-->

    <meta charset="UTF-8">
    <title> Software Engineering </title>
    <link href="images/icon.png" rel="icon"/>
    <style type="text/css">
        body {
            background-color: #b8e6e4;
            font-family: "Georgia", serif;
            margin: 20px;
        }

        keyword {
            color: #a90001;
            font-weight: bold;
        }

        #topBtn {
            display: none;
            position: fixed;
            bottom: 80px;
            right: 20px;
            z-index: 99;
            border: none;
            outline: none;
            background-color: red;
            color: white;
            cursor: pointer;
            padding: 15px;
            border-radius: 10px;
        }

        table, th, td {
            border: 1px solid black;
            border-collapse: collapse;
        }

        th, td {
            padding: 8px;
        }

        #topBtn:hover {
            background-color: #555;
        }

        #homeBtn {
            display: block;
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 99;
            border: none;
            outline: none;
            background-color: red;
            color: white;
            cursor: pointer;
            padding: 15px;
            border-radius: 10px;
        }

        #homeBtn:hover {
            background-color: #555;
        }
    </style>
</head>
<body>
<hr/> <!----------------------------------------------------------------------------------->
<h1> LI Software Engineering Extended 1 </h1>
<hr/> <!----------------------------------------------------------------------------------->
Table of contents
<ol>
    <li><a href="#intro"> Introduction </a></li>
    <li><a href="#models"> Software Process Models </a><ul>
        <li><a href="#models1"> Waterfall Model </a></li>
        <li><a href="#models2"> Evolutionary Development </a></li>
        <li><a href="#models3"> Component-based Software Engineering </a></li>
        <li><a href="#models4"> Incremental Delivery </a></li>
        <li><a href="#models5"> Spiral Development </a></li>
    </ul></li>
    <li><a href="#reqeng"> Requirements Engineering </a><ul>
        <li><a href="#reqeng1"> Software Development Lifecycle </a></li>
    </ul></li>
    <li><a href="#system"> System </a><ul>
        <li><a href="#system1"> Critical System </a></li>
        <li><a href="#system2"> Dependability </a></li>
        <li><a href="#system3"> Faults and Failures </a></li>
    </ul></li>
    <li><a href="#agile"> Rapid and Extreme Programming </a><ul>
        <li><a href="#agile1"> Rapid Software Development </a></li>
        <li><a href="#agile2"> Agile Methods </a></li>
        <li><a href="#agile3"> Rapid Application Development </a></li>
    </ul></li>
    <li><a href="#inception"> Inception Phase </a><ul>
        <li><a href="#inception1"> Business Process Modelling </a></li>
        <li><a href="#inception2"> Activity Diagram </a></li>
    </ul></li>
    <li><a href="#reqdoc"> Requirements Documentation </a></li>

</ol>
<hr/> <!----------------------------------------------------------------------------------->

<h2 id="intro"> 1 &ndash; Introduction to Software Engineering </h2>
<p> What is software engineering? It is a branch of systems engineering concerned with the development of large and
    complex software intensive systems. It focuses on <strong> real world goals </strong> for, services provided by, and
    constrains on such systems. There is also the precise <strong> specification of systems structure and
        behaviour </strong>, and the implementations of these specifications. Furthermore, the activities required in
    order to develop <strong> an assurance </strong> that the specifications and the real world goals have been met.
    Also the <strong> evolution </strong> of these systems over time, and across systems families. It is also concerned
    with the <strong> processes, methods and tools </strong> for the development of software intensive systems in an
    <strong> economic and timely manner</strong>. </p>

<p><strong> Problems in system development </strong> may come from either the End-user's perspective, the Client's
    perspective, or the Developer's perspective. </p>
<p> Problems: End-user </p>
<ul>
    <li> System is not finished</li>
    <li> System has poor design, hard to use, poor interface, useless 'help'</li>
    <li> System is pretty but not useful</li>
</ul>
<p> Problems: Client </p>
<ul>
    <li> Project is overbudget</li>
    <li> Project is delivered late</li>
    <li> Project is no longer needed</li>
    <li> System is not trustworthy or safe to use</li>
</ul>
<p> Problems: Developer </p>
<ul>
    <li> Clients changed their minds</li>
    <li> There is not enough time to complete the project</li>
    <li> Development is disturbed by changing technology</li>
    <li> Developer does not have the necessary skills to fix or develop</li>
    <li> And sometimes, the system works fine but it's just the user with the problems</li>
</ul>

<p> Things go wrong because of two reasons: Quality and Productivity </p>
<ul>
    <li> Quality <ul>
        <li> The wrong problem is addressed so the system conflicts with business strategy</li>
        <li> The context is neglected</li>
        <li> The project has poor software engineering &ndash; incorrect analysis or design, or the team simply lack
            skills
        </li>
        <li> The project is carried out for the wrong reason</li>
    </ul> </li>

    <li> Productivity <ul>
        <li> The client needs change over time, so there is always a requirements drift</li>
        <li> External event changes the environment, e.g. legislation, change in technology</li>
        <li> Poor project management</li>
        <li> Implementation not feasible with over ambitious aims</li>
    </ul> </li>
</ul>

<p> Software Engineering is one of the most technically challenging and practically demanding subjects in computer science. It addresses problems which are faced by day-to-day practitioners. </p>

<hr/> <!----------------------------------------------------------------------------------->

<h2 id="models"> 2 &ndash; Software Process Models </h2>
<p> A structured set of activities required to develop a software system. It consists of <keyword> Specification, Design, Validation, Evolution</keyword>. A <keyword> software process model</keyword> is an abstract representation of a process. It presents a description of a process from some particular perspective. </p>
<p> Process models: </p>
<ul>
    <li> Waterfall Model: Separate and distinct phases of specification and development. </li>
    <li> Evolutionary Development: Specification, development and validation are interleaved. </li>
    <li> Component-based Soft Eng: The system is assembled from existing components. </li>
</ul>

<h3 id="models1"> 2.1 &dash; Waterfall Model </h3>
<img src="images/softeng/models1.JPG"/>
<ol>
    <li> <keyword> Requirements analysis and definition </keyword> <ul>
        <li> The process of establishing what services are required and the constraints on the system's operation and development. </li>
        <li> Requirements Engineering Process, which includes feasibility study, requirements elicitation and analysis, requirements specification, requirements validation. <br/><img src="images/softeng/models2.JPG"/> </li>
    </ul></li>

    <li> <keyword> System and software design </keyword> a structure that realises the specification <ul>
        <li> Architectural design </li>
        <li> Abstract specification </li>
        <li> Interface design </li>
        <li> Component design </li>
        <li> Data structure design </li>
        <li> Algorithm design </li>
        <li> And so on... <br/> <img src="images/softeng/models3.JPG"/> </li>
    </ul></li>

    <li> <keyword> Implementation and unit testing </keyword> <ul>
        <li> Have to already produce executable code. </li>
        <li> Unit testing individual components for functions, classes or programs independently. </li>
        <li> Components may be functions or objects or coherent groupings of these entities. </li>
    </ul></li>

    <li> <keyword> Integration and system testing </keyword> <ul>
        <li> System testing: Testing the system as a while. Testing of emergent properties is particularly important. </li>
        <li> Acceptance testing: Testing with customer data to check that the system meets the customer's needs. </li>
    </ul></li>

    <li> <keyword> Operation and maintenance </keyword> to keep the system going. </li>
</ol>

<p><strong> Problems of Waterfall Model </strong></p>
<ul>
    <li> One phase has to be complete before moving on to the next phase. </li>
    <li> Inflexible partitioning of the project into distinct stages makes it difficult to respond to changing customer requirements. <br/> Therefore this model is only appropriate when the requirements are well understood and the changing will be fairly limited during the design process. </li>
    <li> But only a few business systems have stable requirements. </li>
</ul>

<h3 id="models2"> 2.2 &ndash; Evolutionary Development </h3>
<p> Specification, development and validation is all concurrently ongoing. <br/>
    <img src="images/softeng/models4.JPG"/> <br/> </p>
<ul>
    <li> Exploratory development: To work with customers and to evolve a final system from an initial outline specification. Start with well understood requirements and add new features as proposed by the customer. </li>
    <li> Throw-away prototyping: To understand the system requirements. So should start with poorly understood requirements to clarify what is really needed. </li>
</ul>

<p><strong> Problems with Evolutionary Development </strong></p>
<ul>
    <li> Lack of process visibility </li>
    <li> Systems are often poorly structured </li>
    <li> Special skills such as in languages for rapid prototyping may be required </li>
    <li> May not be applicable for small or medium-sized interactive systems </li>
    <li> May not be applicable for parts of large systems like the user interface </li>
    <li> May not be applicable for short-lifetime systems </li>
</ul>

<h3 id="models3"> 2.3 &ndash; Component-based Software Engineering </h3>
<p> This is based on systematic reuse where systems are integrated from existing components or <keyword> Commercial-off-the-shelf (COTS) </keyword> systems. </p>
<p> Process stages include component analysis, requirement modification, system design with reuse, and development and integration. <br/> Reuse-oriented development <br/> <img src="images/softeng/models5.JPG"/> </p>

<h3> Process Iteration </h3>
<p> System requirements <em> ALWAYS </em> evolve in the course of a project, so process iteration where earlier stages are reworked is always part of the process for large systems. Iterations can be applied to any of the generic process models. </p>

<h3 id="models4"> 2.4 &ndash; Incremental Delivery </h3>
<p> Rather than deliver the system as a single delivery, the development and delivery is broken down into increments with each increment delivering part of the required functionality. </p>
<p> User requirements are prioritised and the highest priority requirements are included in early increments. Once the development of an increment is started, the requirements are frozen through for later increments to evolve. </p>
<img src="images/softeng/models6.JPG"/>
<p> The advantage of this development style </p>
<ul>
    <li> Early increments act as a prototype to help elicit requirements for later increments. </li>
    <li> Lower risk of overall project failure. </li>
    <li> The highest priority system services tend to receive the most testing. </li>
    <li> Customer value can be delivered with each increment so system functionality is available earlier. </li>
</ul>

<h3 id="models5"> 2.5 &ndash; Spiral Development </h3>
<p> The process is represented as a spiral rather than as a sequence of activities with backtracking. Each loo[ in the spiral represents a phase in the process. There are no fixed phases such as specification or design &ndash; loops in the spiral are chosen depending on what is required. Risks are explicitly assessed and resolved throughout the process. </p>
<img src="images/softeng/models7.JPG"/>


<h3 id="models6"> 1.6 &ndash; Rational Unified Process (RUP) </h3>
<img src="images/softeng/models8.JPG"/>
<p> There are four RUP phases </p>
<ol>
    <li> <keyword>Inception</keyword>: Establish the business case for the system. <ul>
        <li> Formulating the scope of the project. </li>
        <li> Planning and preparing the business case. </li>
        <li> Synthesizing a candidate architecture. </li>
        <li> Preparing the environment for the project. </li>
    </ul></li>
    <li> <keyword>Elaboration</keyword>: Develop an understanding of the problem domain and the system architecture. <ul>
        <li> Defining, validating the baseline architecture. </li>
        <li> Refining the vision. </li>
        <li> Creating detail of iteration plans for the construction phase. </li>
        <li> Refining the development case and putting in [lace the development environment. </li>
        <li> Refining the architecture and selecting components. </li>
    </ul></li>
    <li> <keyword>Construction</keyword>: System design, programming and testing. <ul>
        <li> Resource management, control and process optimisation. </li>
        <li> Complete component development and testing against the defined evaluation criteria. </li>
        <li> Assessment of product releases against acceptance criteria for the vision. </li>
    </ul></li>
    <li> <keyword>Transition</keyword>: Deploy the system in its operating environment. <ul>
        <li> Executing deployment plans. </li>
        <li> Finalising end-user support material. </li>
        <li> Testing the deliverable product at the development site. </li>
        <li> Creating a product release and getting user feedback. </li>
        <li> Fine-tuning the product based on feedback. </li>
        <li> Making the product available to end-users. </li>
    </ul></li>
</ol>

<hr/> <!----------------------------------------------------------------------------------->

<h2 id="reqeng"> 3 &ndash; Requirements Engineering (RE) </h2>
<p> Requirements form the basis for Project Planning, Risk Management, Acceptance Testing and Change Control. </p>
<p> Most project's critical issues are in the requirements area. Major gaps in Requirements tend to be critical to a project success. Producing a good set of requirements is likely the most difficult job in software system development. </p>

<h4> Recurring problems </h4>
<ul>
    <li> Lack of functional requirements by either no requirements have been written, usage scenario not understood and documented, functionality of the system incomplete, customer not known and not contacted, or no acceptance criteria for the system. </li>
    <li> Lack of performance and capacity requirements: Number and/or types of users undocumented, transaction and data volumes unknown. </li>
    <li> Lack of operations, administration and management requirements. </li>
</ul>

<p> Good requirements describe <em> what </em> the system is supposed to do, <strong> not </strong> <em> how </em> the system is supposed to do it. Remember the 5W's and one H. </p>

<p> Requirements are <strong> not </strong> a description of how the system provides the needed functionality. Requirements should <strong>not</strong> specify technology or implementation except where those items are customer constraints. Requirements should not contain assumptions, should not be indecisive with words like "would", "could", "flexible" in the document. The item <strong> will </strong> or <strong> will not </strong> be in the system. Requirement should not be inconsistent or conflicting too. </p>

<p> Requirements are description of <strong> what </strong> the entire system is supposed to do: </p>
<ul>
    <li> Reflective of customer need </li>
    <li> Constraints imposed by the customer </li>
    <li> Constraints imposed by business and marketing needs </li>
    <li> Unambiguous (clear and concise) </li>
    <li> Complete </li>
    <li> Prioritised </li>
    <li> Traceable, meaning able to be followed </li>
    <li> Implementable within project constraints like schedule and budget </li>
    <li> Formally accepted by the customer, systems engineering and development, system test, and under change control </li>
</ul>
<p> Requirements are sometimes referenced for contacts, and also sometimes considered to be contract between systems engineering and development. </p>

<p> Customer and end-user are not always the same person. The end-user is the person who interacts with the system to get the job done, while the customer typically pays for the system. They may have similar or conflicting objectives. Sometimes delighting your end-user delights the customer, but remember that the customer pays for the job. So it is very important to get the customer involved in the initial phase of RE, if at all possible. </p>

<h3 id="reqeng1"> 3.1 &ndash; Software Development Lifecycle (SDLC) </h3>
<p> We have the <keyword> V Model</keyword>: If problems are found during Verification or Validation phase, the LHS of the V is re-executed to fix the problem. </p>
<img src="images/softeng/reqeng1.JPG"/>
<p> Prototyping allows all or part of the system to be constructed quickly in the hopes of clarifying and understanding issues. Iterate requirements and design to ensure common understanding. </p>

<h4> Role of requirements engineering </h4>
<p> Requirements influence the whole development from the start to end. Testing is with respect to the requirements. A system is accepted against Stakeholder's requirements during Acceptance Test Phase as shown in the image below. </p>
<img src="images/softeng/reqeng2.JPG"/>

<p> RE provides communication amongst projects. <br/> <keyword>Requirements traceability</keyword> refers to the ability to understand how high-level requirements (goals, objectives etc) are transformed into low-level requirements (mapping between layers of information: one-to-many usually). It is the ability to assess impact changes introduced at various phases of development lifecycle, and the ability to track progress. <br/> <em> Stakeholders req. met by system req &rightarrow; partitioned into subsystem req &rightarrow; implemented as components </em></p>

<p> <keyword>Traceability</keyword> is the use of requirements management tools to link requirements statements in on layer with statement in another. </p>

<p> Main requirements activities include </p>
<ul>
    <li> Requirements inception </li>
    <li> Requirements analysis </li>
    <li> Requirements specification </li>
    <li> Requirements verification and validation </li>
    <li> Requirements management </li>
    <li> Requirements documents </li>
</ul>

<hr/> <!----------------------------------------------------------------------------------->

<h2 id="system"> 4 &ndash; Systems </h2>
<p> A <keyword>system</keyword> is an organised or complex whole: an assemblage or combination of things or parts forming a complex or unitary whole. It is also a set of interrelated elements. </p>

<p> If the elements of a system are of a reasonable degree of complexity, which made them systems, then we call them <keyword>sub-systems</keyword>. </p>

<p> The <keyword>environment</keyword> of a system is the set of elements which are NOT part of the system, but a change in any of which can produce a change in the state of the system. </p>

<h3 id="system1"> 4.1 &ndash; Critical Systems </h3>
<p> <keyword>Critical system</keyword> is a system where failure can lead to high economic loss, physical damage, or threats ot life. There are three critical systems: </p>
<ul>
    <li><keyword>Safety-critical</keyword><ul>
        <li> Failure results in loss of life, injury or damage to the environment. </li>
        <li> E.g. Chemical plant protection system </li>
    </ul></li>
    <li><keyword>Mission-critical</keyword><ul>
        <li> Failure results in failure of some goal-directed activity. </li>
        <li> E.g. Spacecraft navigation system </li>
    </ul></li>
    <li><keyword>Business-critical</keyword><ul>
        <li> Failure results in high economic loss. </li>
        <li> E.g. Customer accounting system in a bank </li>
    </ul></li>
</ul>
<p> It is usually the case that the most important system property is the <keyword>dependability</keyword> of the system. The dependability of a system reflects the user's degree of trust in that system. It reflects the extent of the user's confidence that it will operate as users expect and that it will not fail in normal use. </p>

<p> Systems that are not dependable (<keyword>unreliable, unsafe, insecure</keyword>) may be rejected by their users. The cost of critical system failure may be very high such that development method may be used for other types of system. </p>

<p><keyword>Socio-technical</keyword> in an organisational development is an approach to complex organisational work design that recognises the interaction between people and technology in workplaces. </p>
<ul>
    <li><keyword>Hardware failure</keyword><ul>
        <li> Design and manufacturing errors. </li>
        <li> Components have reached the end of their natural life. </li>
    </ul></li>
    <li><keyword>Software failure</keyword><ul>
        <li> Errors in its specification, design or implementation. </li>
    </ul></li>
    <li><keyword>Operational failure</keyword><ul>
        <li> Human operators make mistakes. </li>
    </ul></li>
</ul>

<h3 id="system2"> 4.2 &ndash; Dependability </h3>
<p> <keyword>Dependability</keyword> of a system equates to its trustworthiness. The principal dimensions of dependability are: </p>
<ul>
    <li><keyword>Availability</keyword><ul>
        <li> Probability that the system will be available to deliver services when requested. </li>
    </ul></li>
    <li><keyword>Reliability</keyword><ul>
        <li> Probability that system services will be delivered as specified. </li>
    </ul></li>
    <li><keyword>Safety</keyword><ul>
        <li> The ability of the system to operate without catastrophic failure. </li>
    </ul></li>
    <li><keyword>Security</keyword><ul>
        <li> The ability of the system to protect itself against accidental or deliberate intrusion. </li>
    </ul></li>
    <li>Repairability<ul>
        <li> Reflects the extent to which the system can be repaired in the event of a failure. </li>
    </ul></li>
    <li>Maintainability<ul>
        <li> Reflects the extent to which the system can be adapted to new requirements. </li>
    </ul></li>
    <li>Survivability<ul>
        <li> Reflects the extent to which the system can deliver services whilst under hostile attack. </li>
    </ul></li>
    <li>Error tolerance<ul>
        <li> Reflects the extent to which the user-input errors can be avoided and tolerated. </li>
    </ul></li>
</ul>

<p>Untrustworthy systems may cause loss of valuable information. It may be rejected by their users and failures cost very high. </p>

<p> There will be <strong>trade-offs</strong> between performance and dependability. </p>
<p> The costs tend to increase exponentially as increasing levels of dependability are required. This is because of: </p>
<ul>
    <li> Use of more expensive <strong>development techniques</strong> </li>
    <li> Increased <strong>testing and system validation</strong> </li>
</ul>
<img src="images/softeng/system1.JPG"/>

<p><keyword>Safety</keyword> is the system's ability to operate <strong>without danger of causing human injury or death</strong> and <strong>without damage to the system's environment</strong>.</p>

<p><keyword>Security</keyword> of a system is the system's ability to <strong>protect</strong> itself from <strong>accidental or deliberate external attack</strong>. It is an essential pre-requisite for availability, reliability and safety. </p>
<p> Damages that can be done from insecure systems: </p>
<ul>
    <li> Denial of service (DOS) </li>
    <li> Corruption of programs or data </li>
    <li> Disclosure of confidential information </li>
</ul>

<h3 id="system3"> 4.3 &ndash; Faults and Failures </h3>
<p> There are some terminologies related to reliability: </p>
<ul>
    <li><keyword>System Failure</keyword><ul>
        <li> An event that occurs at some point in time when the system does not deliver a service as expected by its users. </li>
    </ul></li>
    <li><keyword>System Error</keyword><ul>
        <li> An errorneous system state that can lead to system behavior that is unexpected by system users. </li>
    </ul></li>
    <li><keyword>System Fault</keyword><ul>
        <li> A characteristic of a software system that can lead to a system error. E.g. failure to initialise a variable leading to null pointers. </li>
    </ul></li>
    <li><keyword>Human Error</keyword><ul>
        <li> Human behaviour that results in the introduction of faults into a system. </li>
    </ul></li>
</ul>
<p> <keyword>Failures</keyword> are usually a result of system errors that are derived from the faults in the system. Faults do not necessarily result in system errors. Errors do not necessarily lead to system failures. </p>

<p><keyword>Fault avoidance</keyword> development techniques are used to minimise the possibility of mistakes or trap mistakes before they result in faults.</p>
<p><keyword>Fault detection and removal</keyword> verification and validation techniques are used to detect errors before the system goes into service. </p>
<p><keyword>Fault tolerance</keyword> runtime techniques are used to ensure that system faults do not result in system errors which do not lead to system failures. </p>

<hr/> <!----------------------------------------------------------------------------------->

<h2 id="agile"> 5 &ndash; Rapid and Extreme Programming </h2>
<h3 id="agile1"> 5.1 &ndash; Rapid Software Development (RSD) </h3>
<p><keyword>RSD</keyword> is due to the fact that business environments always change, so the business have to respond to new opportunities and competition. This is normally used for small and medium sized systems. </p>
<p> Characteristics </p>
<ul>
    <li>Processes of <strong>specification</strong>, <strong>design</strong> and <strong>implementation</strong> are <keyword>concurrent</keyword>.</li>
    <li>System is developed in a series of <keyword>increments</keyword>.</li>
    <li>End-users evaluate each increment and make proposals for later increments.</li>
    <li>Things may easily go wrong so <strong>best suited</strong> for <keyword>experienced</keyword> and <keyword>skillful</keyword> development teams. </li>
</ul>
<p> Waterfall model is <keyword>impractical</keyword> here.</p>
<h4> Iterative development process </h4>
<img src="images/softeng/agile1.JPG"/>

<h3 id="agile2"> 5.2 &ndash; Agile Methods </h3>
<ul>
    <li> Focus on the code rather than design </li>
    <li> Iterative approach </li>
    <li> Intended to deliver working software quickly and evolve quickly </li>
</ul>
<p> Agile methods are <strong>best suited</strong> to small or medium sized business systems. </p>
<p><strong>Principles of Agile Methods</strong></p>
<ul>
    <li> <keyword>Customer involvement</keyword> <ul>
        <li> Customers are to provide and prioritise new requirements and evaluate iterations. </li>
    </ul> </li>
    <li> <keyword>Incremental delivery</keyword> <ul>
        <li> Software is developed in increments. </li>
    </ul> </li>
    <li> <keyword>People not Process</keyword> <ul>
        <li> Team members should be allowed to develop their own ways of working. </li>
    </ul> </li>
    <li> <keyword>Embrace Change</keyword> <ul>
        <li> Design the system to accommodate constant changes. </li>
    </ul> </li>
    <li> <keyword>Maintain Simplicity</keyword> <ul>
        <li> Actively work to eliminate complexity from the system. </li>
    </ul> </li>
</ul>

<h4> Problems with Agile Method</h4>
<ul>
    <li> Can be difficult to keep the <keyword>interest</keyword> of involved customers. </li>
    <li> Team members <keyword>not suited</keyword> for the method. </li>
    <li> <keyword>Prioritising changes</keyword> can be difficult where there are multiple stakeholders. </li>
    <li> <keyword>Maintaining simplicity</keyword> requires extra work. </li>
    <li> <keyword>Contracts</keyword> </li>
</ul>

<h4> Extreme Programming (XP) </h4>
<p> This is an agile method that takes an 'extreme' approach to iterative development. </p>
<ul>
    <li> New versions may be built <keyword>several times per day</keyword>. </li>
    <li> Increments are delivered to customers <keyword>every 2 weeks</keyword>. </li>
    <li> Build is only accepted if <keyword>tests run successfully</keyword>. </li>
</ul>

<p><strong>Five Values of XP</strong></p>
<ul>
    <li><keyword>Communication</keyword><ul>
        <li> Nothing can be done well without communicating. </li>
    </ul></li>
    <li><keyword>Simplicity</keyword><ul>
        <li> Do the simplest thing that could possibly work. </li>
    </ul></li>
    <li><keyword>Feedback</keyword><ul>
        <li> Put valuable requirements into production as early as possible. </li>
    </ul></li>
    <li><keyword>Courage</keyword><ul>
        <li> Do the right thing! Throw away code that is no longer needed. </li>
    </ul></li>
    <li><keyword>Respect</keyword><ul>
        <li> Team members must respect other's work. </li>
    </ul></li>
</ul>

<h4> The XP Release Cycle </h4>
<img src="images/softeng/agile2.JPG"/>

<h4> XP Practices </h4>
<ul>
    <li><keyword>Incremental Planning</keyword><ul>
        <li> Requirements are recorded on <strong>story cards</strong> that focuses on <strong>user needs</strong>.</li>
        <li> Stories should be prioritised and chosen <strong>by the customer</strong>. </li>
        <li> Break down each story into tasks. <ul>
            <li> Each task has estimates of <em>schedule</em> and <em>cost</em>. </li>
        </ul></li>
    </ul></li>
    <li><keyword>Small Releases</keyword><ul>
        <li> Focus on releasing minimal functionality. </li>
        <li> Each increment adds more functionality. </li>
    </ul></li>
    <li><keyword>Simple Design</keyword><ul>
        <li> Design just enough to meet requirements. </li>
        <li> Even though it might lead to <strong>poor design</strong> and <strong>multiple refactorings</strong>. </li>
    </ul></li>
    <li><keyword>Test-first Development</keyword><ul>
        <li> Automated test framework is used to write tests for a new piece of functionality <strong>before</strong> the             functionality itself is implemented. <ul>
            <li> This is to <strong>clarify</strong> the requirements. </li>
            <li> Tests are written as <strong>programs</strong> rather than data. </li>
            <li> Tests are run when new functionality is added to ensure the update doesn't introduce errors. </li>
        </ul></li>
    </ul></li>
    <li><keyword>Refactoring</keyword><ul>
        <li> Refactor continuously as soon as an improvement is found. </li>
        <li> This is to keep code <strong>simple</strong> and <strong>maintainable</strong>. </li>
    </ul></li>
    <li><keyword>Pair Programming</keyword><ul>
        <li> Developers work in <strong>pairs</strong>. <ul>
            <li> Develop common ownership and spreads knowledge. </li>
            <li> Serves as an informal review process. </li>
            <li> Encourages refactoring. </li>
        </ul></li>
    </ul></li>
    <li><keyword>Collective Ownership</keyword><ul>
        <li> Everybody works on everything. No <strong>islands of expertise</strong>. </li>
    </ul></li>
    <li><keyword>Continuous Integration</keyword><ul>
        <li> Work is integrated to the system as soon as it is finished. </li>
        <li> All of the unit tests in the system must pass. </li>
    </ul></li>
    <li><keyword>Sustainable Pace</keyword><ul>
        <li> Large amounts of <strong>overtime</strong> are not considered acceptable. </li>
        <li> This reduces the <strong>net productivity</strong> of code. </li>
    </ul></li>
    <li><keyword>On-site customer</keyword><ul>
        <li>End-users and customers are <strong>members</strong> of the development team. </li>
    </ul></li>
</ul>

<h4> Critiques of XP </h4>
<ul>
    <li><strong>Code-centered</strong> rather than design-centered, bad for large systems. </li>
    <li>Not producing <strong>readable code</strong>.</li>
    <li>Lack of <strong>structured</strong> review process.</li>
    <li><strong>Quality through testing</strong>.</li>
    <li>Limited to a <strong>narrow</strong> segment of software work.</li>
    <li>Limited <strong>management support</strong>.</li>
    <li>Lack of <strong>transition support</strong>.</li>
</ul>

<h4> User Stories and Use Cases </h4>
<table>
    <tr>
        <th> User Story </th>
        <th> Use Case </th>
    </tr>
    <tr>
        <td> Small scale and easy-to-use presentation of information. </td>
        <td> Describes process and steps in detail. </td>
    </tr>
    <tr>
        <td> Formulated in everyday language of the user, no technical words. </td>
        <td> Can use technical words. </td>
    </tr>
    <tr>
        <td> Can be accompanied by Acceptance Testing procedures. </td>
        <td> Can be delivered in a stand-alone document. </td>
    </tr>
    <tr>
        <td> For customers </td>
        <td> For developers </td>
    </tr>
</table>

<h3 id="agile3"> 5.3 &ndash; Rapid Application Development (RAD) </h3>
<p> This development includes <keyword>Visual Development</keyword> and <keyword>COTS</keyword>.</p>
<ul>
    <li> Designed to develop <keyword>data-intensive</keyword> business applications. </li>
    <li> Rely on programming and presenting information from a <keyword>database</keyword>. </li>
    <li> Using <keyword>special tools</keyword> and <keyword>programming languages</keyword>. </li>
</ul>
<p> RAD environments include support for <keyword>interface generation</keyword> interactively: form <strong>definition</strong> using drag and drop techniques; form <strong>linking</strong> and form <strong>verification</strong>. </p>

<h4> Visual Programming </h4>
<p> Scripting languages such as Visual Basic. Prototype is created from an interface. </p>
<p> An example would be like below </p>
<img src="images/softeng/agile3.JPG"/>

<h4>Problems with Visual Development</h4>
<ul>
    <li> Difficult to coordinate <keyword>team-based</keyword> development. </li>
    <li> No explicit system architecture. </li>
    <li> Can have maintainability problems. </li>
    <li> Maintenance has to be done through original environment. </li>
    <li> Hard to <keyword>integrate</keyword> with other systems. </li>
</ul>

<h4> COTS Reuse </h4>
<p> As mentioned before in <a href="#models3">here</a>, COTS refers to <keyword>already available</keyword> applications. <keyword>Configure</keyword> and <keyword>link</keyword> existing off the shelf systems for an effective approach to rapid development. </p>

<p> Some application prototypes can be created by developing a <keyword>compound document</keyword>. This document has <keyword>active elements</keyword> like a spreadsheet that <strong>allows user computations</strong>. Each active elements has an <keyword>associated application</keyword> which is invoked when that element is selected. The document itself is the <keyword>integrator</keyword> for different applications. </p>

<hr/> <!----------------------------------------------------------------------------------->

<h2 id="inception"> 6 &ndash; Inception Phase </h2>
<p> The <keyword>Inception phase</keyword> focuses on the <keyword>business process modeling</keyword>, <keyword>requirements capture</keyword>, and the <keyword>start of analysis</keyword>. </p>

<p> Analysis has three parts: </p>
<ul>
    <li> Business Modelling </li>
    <li> Requirements Analysis </li>
    <li> System Analysis </li>
</ul>

<h3 id="inception1"> 6.1 &ndash; Business Process Modelling </h3>
<ol>
    <li> Build a <keyword>business process map</keyword> </li>
    <li> Develop <keyword>business scenarios</keyword> </li>
    <li> Derive <keyword>business workflows</keyword> </li>
    <li> Produce <keyword>business object models</keyword> </li>
</ol>
<h4> Business Process Map </h4>
<img src="images/softeng/inception1.JPG"/>

<h4> Business Scenario Analysis </h4>
<p> Forms the basis of analysis process: </p>
<ul>
    <li> <keyword>Business</keyword> analysis </li>
    <li> <keyword>Use case</keyword> analysis </li>
</ul>
<p> There are four parts to analysis is to describe and identify: </p>
<ol>
    <li> <keyword>Scenarios</keyword> &ndash; described by primary and alternative paths </li>
    <li> <keyword>Primary Paths</keyword> </li>
    <li> <keyword>Alternative Paths</keyword> </li>
    <li> <keyword>Exceptions</keyword> &ndash; when alternative paths fails </li>
</ol>

<p> The <keyword>80/20 principle</keyword> states that 80% of <strong>effort</strong> goes into 20% of <strong>activity</strong>. </p>

<h3 id="inception2"> 6.2 &ndash; Activity Diagrams </h3>
<p> A branch of UML diagrams, made by merging scenario analysis' <keyword>primary</keyword> and <keyword>alternative paths</keyword>. Used to <keyword>model business processes</keyword>. </p>
<img src="images/softeng/inception2.jpg"/>
<p> Apart from these we also have <keyword>swimlanes</keyword> which are useful to separate actors. </p>
<img src="images/softeng/inception5.JPG"/>
<p> Some examples: </p>
<div>
<img src="images/softeng/inception3.JPG"/>
<img src="images/softeng/inception4.JPG"/>
</div>

<h4> Stakeholder Involvement </h4>
<p> Building business processes requires many discussions with clients and stakeholders. </p>
<p> Record process in a <keyword>Process Catalogue</keyword>.</p>
<ul>
    <li> <keyword>Goals</keyword> of the process </li>
    <li> Necessary <keyword>preconditions</keyword> before the process can run </li>
    <li> <keyword>Criticality</keyword> of the process </li>
    <li> <keyword>Business actors</keyword> involved in the process </li>
</ul>

<hr/> <!----------------------------------------------------------------------------------->

<h2 id="reqdoc"> 7 &ndash; Requirements Documentation </h2>
<p> A <keyword>requirement</keyword> may be the basis for a bid for a contract, or it may be the basis for the contract itself, or both. </p>

<h3 id="reqdoc1"> 7.1 &ndash; Types of Requirements </h3>
<ul>
    <li> <keyword>User</keyword> <ul>
        <li> Statements in <keyword>natural language</keyword> and diagrams of the services the system provides and its constraints. </li>
        <li> Should describe <keyword>functional</keyword> and <keyword>non-functional</keyword> requirements. </li>
        <li> Written for <keyword>clients</keyword> without technical knowledge. </li>
    </ul></li>
    
    <li> <keyword>System</keyword> <ul>
        <li> Descriptions of the system's functions, services and operational <keyword>constraints</keyword>. </li>
        <li> Defines what should be <keyword>implemented</keyword>. </li>
        <li> Part of the contract. </li>
    </ul></li>
</ul>

<h3 id="reqdoc2"> 7.2 &ndash; Functional and Non-Functional Requirements </h3>
<p> Brief definition of these two: Functional requirements describe <strong>what</strong> the system <keyword>should do</keyword> while non-functional requirements describe <strong>how</strong> the system <keyword>works</keyword> </p>
<img src="images/softeng/reqdoc1.jpg"/>
<p> Requirements have to be written properly without any <keyword>ambiguity</keyword> or developers may interpret it differently than what is asked for. </p>

<p> Requirements have to be both complete and consistent: </p>
<ul>
    <li> Complete <ul>
        <li> They should include <keyword>descriptions</keyword> of all facilities required. </li>
    </ul></li>

    <li> Consistent <ul>
        <li> There should be <keyword>no conflicts or contradictions</keyword> in the descriptions of the system facilities. </li>
    </ul></li>
</ul>

<h4> Types of Non-functional Requirements </h4>
<ul>
    <li> <keyword>Product</keyword> requirements <ul>
        <li> Specify the way the delivered product must behave. </li>
        <li> Performance, Reliability, Availability, etc. </li>
    </ul> </li>

    <li> <keyword>Organisational</keyword> requirements <ul>
        <li> Consequence of organisational policies and procedures </li>
        <li> Process standards used, implementation requirements, etc. </li>
    </ul> </li>

    <li> <keyword>External</keyword> requirements <ul>
        <li> Factors which are external to the system and its development process </li>
        <li> Legislative requirements, etc. </li>
    </ul> </li>
</ul>

<p> A requirement is <keyword>verifiable</keyword> if it is possible to create and run a <keyword>test</keyword> of the final system that clearly demonstrates the requirement has been met. </p>

<p> <keyword>Domain</keyword> requirements are derived from the application domain and describe <keyword>system characteristics</keyword> and features that reflect the domain. </p>

<h4> Guidelines for Writing Requirements </h4>
<p> Create a <keyword>standard format</keyword> and use it for all requirements. Use language in a constant way. Use <keyword>shall</keyword> for mandatory requirements, <keyword>should</keyword> for desirable requirements. Avoid computing <keyword>jargon</keyword>. </p>

<h4> Problems with Natural Language </h4>
<ul>
    <li> <keyword>Ambiguous</keyword> &ndash; Different people may interpret it differently. </li>
    <li> <keyword>Too flexible</keyword> &ndash; Many ways to describe the same thing. </li>
    <li> <keyword>Lack of modularisation</keyword> &ndash; NL Structures are inadequate to structure system requirements. </li>
</ul>

<p> <strong>Alternatives to NL specification</strong> </p>
<table>
    <tr>
        <th> Notation </th>
        <th> Description </th>
    </tr>
    <tr>
        <td> Structured natural language </td>
        <td> Depends on defining standard forms to express the specification. </td>
    </tr>
    <tr>
        <td> Design description languages </td>
        <td> Uses a language like a programming language with more abstract features and models to specify the requirements . </td>
    </tr>
    <tr>
        <td> Graphical notations </td>
        <td> Graphics supplemented with text annotations. This includes use-case descriptions and sequence diagrams. </td>
    </tr>
    <tr>
        <td> Mathematical specifications </td>
        <td> Languages based on math concepts like finite state machines. </td>
    </tr>
</table>

<h3 id="reqdoc3"> 7.3 &ndash; Sequence Diagrams </h3>
<p> Shows the <keyword>sequence of events</keyword> that take place during some <keyword>user interaction</keyword> with a system. </p>
<div>
<img src="images/softeng/reqdoc2.JPG"/>
<img src="images/softeng/reqdoc3.JPG"/>
</div>
<ul>
    <li> <keyword>Synchronous</keyword> <ul>
        <li> Method call and <keyword>wait for return</keyword>. </li>
        <li> Represented as full solid arrow. </li>
        <li> Dashed arrow indicated return. </li>
    </ul> </li>

    <li> <keyword>Asynchronous</keyword> <ul>
        <li> Method call <keyword>without return</keyword>. </li>
        <li> Represented as arrow without solid head. </li>
    </ul> </li>
</ul>

<h3 id="reqdoc4"> About of Requirements Documents </h3>
<h4> Users </h4>
<ul>
    <li> System Customers </li>
    <li> Software Managers </li>
    <li> System Engineers </li>
    <li> System Test Engineers </li>
    <li> System Maintenance Engineers </li>
</ul>

<h4> IEEE Requirements Standard </h4>
<p> A useful starting point for defining more detailed specific requirements standards. </p>
<ul>
    <li> Introduction </li>
    <li> General Description </li>
    <li> Specific Requirements </li>
    <li> Appendix </li>
    <li> Index </li>
</ul>

<hr/> <!----------------------------------------------------------------------------------->

<h2 id="reqcap"> 8 &ndash; Requirements Capture </h2>
<h3 id="reqcap1"> 8.1 &ndash; About Requirements Capture </h3>
<p> Involves <keyword>analysts</keyword> working with clients to find out about the application domain, services that the system should provide and the system's operational constraints. May involve <keyword>stakeholders</keyword>. </p>

<h4> Problems with Requirements </h4>
<ul>
    <li> Stakeholders <keyword>don't know what they really want</keyword>. </li>
    <li> Stakeholders express requirements in their <keyword>own terms</keyword>. </li>
    <li> Different stakeholders may have <keyword>conflicting requirements</keyword>. </li>
    <li> Organisational and political factors may <keyword>influence</keyword> the system requirements. </li>
    <li> Requirements <keyword>change</keyword> during the analysis process. </li>
</ul>

<h4> Process Activities </h4>
<ul>
    <li><keyword>Requirements Discovery</keyword><ul>
        <li> <strong>Interacting with stakeholders</strong> to discover their requirements. </li>
    </ul></li>

    <li><keyword>Requirements Classification and Organisation</keyword><ul>
        <li> <strong>Group related requirements</strong> and <strong>organises</strong> them into <strong>coherent clusters</strong>. </li>
    </ul></li>

    <li><keyword>Prioritisation and Negotiation</keyword><ul>
        <li><strong>Prioritising requirements</strong> and <strong>resolving requirement conflicts</strong>.</li>
    </ul></li>

    <li><keyword>Requirements Documentation</keyword><ul>
        <li> Requirements are <strong>documented</strong> and input into next iteration. </li>
    </ul></li>
</ul>

<h3 id="reqcap2"> 8.2 &ndash; Viewpoints </h3>
<p> A way of <keyword>structuring</keyword> the requirements to represent the <keyword>perspectives</keyword> of different stakeholders. Stakeholders may be classified under different viewpoints. </p>

<h3 id="reqcap3"> 8.3 &ndash; Fact-Finding Techniques </h3>
<table>
    <tr>
        <th> Technique </th>
        <th> Definition </th>
        <th> Pros </th>
        <th> Cons</th>
    </tr>
    <tr>
        <td><keyword>Background Reading</keyword></td>
        <td> Company reports, organisation charts, policy manuals of existing systems. </td>
        <td> Helps understand the organisation and prepare for other types of fact finding. </td>
        <td> Written documents often do not match reality; out of date for example. </td>
    </tr>
    <tr>
        <td><keyword>Interviewing</keyword></td>
        <td> A <strong>structured meeting</strong> between the analyst and a stakeholder. </td>
        <td><ul>
            <li> Allows analyst to adapt to what the interviewee says. </li>
            <li> Analyst can probe in <strong>greater depth</strong>.</li>
            <li> Interview can be terminated early if interviewee has nothing to say. </li>
        </ul></td>
        <td><ul>
            <li> Interviews are <strong>time-consuming</strong> and therefore <strong>costly</strong>. </li>
            <li> Results have to be <strong>transcribed or written up</strong> after the interview. </li>
            <li> Can be subject to <strong>bias</strong> if the analyst has a closed mind. </li>
            <li> Different interviewees may provide <strong>conflicting information</strong>. </li>
        </ul></td>
    </tr>
    <tr>
        <td><keyword>Observation</keyword></td>
        <td> Allows the analyst to identify social and organisational factors. </td>
        <td><ul>
            <li> Provides <strong>first-hand</strong> experience of how the current system operates. </li>
            <li> Data collected in <strong>real time</strong> hence having high level of validity. </li>
            <li> Baseline performance data can be collected. </li>
            <li> Can be used to verify other sources of information. </li>
        </ul></td>
        <td><ul>
            <li> Most people don't like being observed and may <strong>behave differently</strong>. </li>
            <li> Required <strong>skilled and trained</strong> observer to be effective. </li>
            <li> Can give rise to <strong>logistical problems</strong>. </li>
            <li> <strong>Ethical issues</strong> can arise if sensitive information is handled. </li>
        </ul></td>
    </tr>
    <tr>
        <td><keyword>Document Sampling</keyword></td>
        <td> Collect copies of blank and completed documents. Analyse the document to determine <strong>inputs and outputs</strong> for each activity. </td>
        <td>Can be used to gather <strong>quantitative data</strong>. Also used to estimate <strong>error rates</strong>.</td>
        <td> Limited use if the system is going to change significantly. </td>
    </tr>
    <tr>
        <td><keyword>Questionnaires</keyword></td>
        <td> Series of written questions with limited range of possible answers. </td>
        <td><ul>
            <li> <strong>Economical method</strong> of gathering data from a large number of people. </li>
            <li> Results can be <strong>analysed easily</strong>. </li>
        </ul></td>
        <td><ul>
            <li> Good questionnaires are difficult to construct. </li>
            <li> May be necessary to <strong>follow up</strong> the questionnaire by an interview. </li>
            <li> May suffer from <strong>low response rates</strong>. </li>
        </ul></td>
    </tr>
</table>

<h3 id="reqcap4"> 8.4 &ndash; Requirements Checking </h3>
<ul>
    <li><keyword>Validity</keyword></li>
    <li><keyword>Consistency</keyword></li>
    <li><keyword>Completeness</keyword></li>
    <li><keyword>Realism</keyword></li>
    <li><keyword>Verifiability</keyword></li>
</ul>

<h3 id="reqcap5"> 8.5 &ndash; Requirements Validation </h3>
<ul>
    <li><keyword>Requirements Reviews</keyword><ul>
        <li> Systematic <strong>manual analysis</strong> of the requirements. </li>
    </ul></li>
    
    <li><keyword>Prototyping</keyword><ul>
        <li> Using an <strong>executable model</strong> of the system to check requirements. </li>
    </ul></li>
    
    <li><keyword>Test-case generation</keyword><ul>
        <li> <strong>Developing tests</strong> for requirements to check testability. </li>
    </ul></li>
</ul>



<hr/> <!----------------------------------------------------------------------------------->



<!-- Utils -->
<button onclick="topFunction()" id="topBtn" title="Go to top">Top</button>
<script>
    // When the user scrolls down 20px from the top of the document, show the button
    window.onscroll = function () {
        scrollFunction()
    };

    function scrollFunction() {
        if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
            document.getElementById("topBtn").style.display = "block";
        } else {
            document.getElementById("topBtn").style.display = "none";
        }
    }

    // When the user clicks on the button, scroll to the top of the document
    function topFunction() {
        document.body.scrollTop = 0;
        document.documentElement.scrollTop = 0;
    }
</script>
<button onclick="window.location.href='index.html'" id="homeBtn" title="Back to Home"> Home</button>
</body>
</html>